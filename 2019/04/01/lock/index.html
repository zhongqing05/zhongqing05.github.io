<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>iOS中几种常用的锁 | 黑夜传说</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="多线程编程中，应该尽量避免资源在线程之间共享，以减少线程之间的相互作用，但是总有多个线程相互干扰的情况下（如多个线程访问一个资源）。在线程必须交互的情况下，就需要一些同步工具，来确保它们交互是安全的。 锁是线程编程同步工具的基础。iOS开发中常用的锁用一下几种：  @synchronized NSLock 对象锁 NSRecuisiveLock 递归锁 NSConditionLock 条件锁 pt">
<meta name="keywords" content="iOS中的锁	信号量和互斥锁的区别  @synchronized">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS中几种常用的锁">
<meta property="og:url" content="http://yoursite.com/2019/04/01/lock/index.html">
<meta property="og:site_name" content="黑夜传说">
<meta property="og:description" content="多线程编程中，应该尽量避免资源在线程之间共享，以减少线程之间的相互作用，但是总有多个线程相互干扰的情况下（如多个线程访问一个资源）。在线程必须交互的情况下，就需要一些同步工具，来确保它们交互是安全的。 锁是线程编程同步工具的基础。iOS开发中常用的锁用一下几种：  @synchronized NSLock 对象锁 NSRecuisiveLock 递归锁 NSConditionLock 条件锁 pt">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-04-01T10:17:59.282Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS中几种常用的锁">
<meta name="twitter:description" content="多线程编程中，应该尽量避免资源在线程之间共享，以减少线程之间的相互作用，但是总有多个线程相互干扰的情况下（如多个线程访问一个资源）。在线程必须交互的情况下，就需要一些同步工具，来确保它们交互是安全的。 锁是线程编程同步工具的基础。iOS开发中常用的锁用一下几种：  @synchronized NSLock 对象锁 NSRecuisiveLock 递归锁 NSConditionLock 条件锁 pt">
  
    <link rel="alternate" href="/atom.xml" title="黑夜传说" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">黑夜传说</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">为了更好的明天而努力</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-lock" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/01/lock/" class="article-date">
  <time datetime="2019-04-01T09:50:49.753Z" itemprop="datePublished">2019-04-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      iOS中几种常用的锁
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>多线程编程中，应该尽量避免资源在线程之间共享，以减少线程之间的相互作用，但是总有多个线程相互干扰的情况下（如多个线程访问一个资源）。在线程必须交互的情况下，就需要一些同步工具，来确保它们交互是安全的。</p>
<p>锁是线程编程同步工具的基础。iOS开发中常用的锁用一下几种：</p>
<ol>
<li>@synchronized</li>
<li>NSLock 对象锁</li>
<li>NSRecuisiveLock 递归锁</li>
<li>NSConditionLock 条件锁</li>
<li>pthread_mutex 互斥锁</li>
<li>dispatch_semaphore  信号量加锁（GCD）</li>
</ol>
<ul>
<li>@synchoronized关键字加锁（互斥锁），性能较差不推荐使用。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  @synchoronized(self)&#123;</span><br><span class="line">   //这里添加要加锁的代码</span><br><span class="line">&#125;</span><br><span class="line">注意点：</span><br><span class="line">1. 加锁代码尽量少</span><br><span class="line">2. 添加OC对象必须在多个线程中都是同一对象</span><br><span class="line">3. 有点是不需要显示的创建锁对象，便可以实现锁的机制。</span><br><span class="line">3. @synchronized块会隐藏的添加一个异常处理程序来保护代码，该处理层会在异常抛出是自动释放互斥锁。所以如果不想让隐试的异常处理例程带来额外开销，你可以考虑锁对象。</span><br></pre></td></tr></table></figure>
<p>以面通过买票的例子展示使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//设置票的张数</span><br><span class="line">-(void)startSaleTickets</span><br><span class="line">&#123;</span><br><span class="line">    _tickets = 5;//设置票的总数</span><br><span class="line">    dispatch_async(_saleticket_queue, ^&#123;</span><br><span class="line">        [self saleTickets];</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(_saleticket_queue, ^&#123;</span><br><span class="line">        [self saleTickets];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//@synchronized</span><br><span class="line">-(void)saleTickets</span><br><span class="line">&#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        @synchronized (self) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:1];</span><br><span class="line">            if (_tickets &gt; 0) &#123;</span><br><span class="line">                _tickets -- ;</span><br><span class="line">                NSLog(@&quot;剩余票数:%d, Thread:%@&quot;,_tickets,[NSThread currentThread]);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                NSLog(@&quot;票已经卖完：Thread:%@&quot;,[NSThread currentThread]);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下是打印</p>
<blockquote>
<pre><code>2019-04-01 14:19:27.397588+0800 LockTest[4435:147099] 剩余票数:4, Thread:&lt;NSThread: 0x600000c8c540&gt;{number = 3, name = (null)}
2019-04-01 14:19:28.398071+0800 LockTest[4435:147099] 剩余票数:3, Thread:&lt;NSThread: 0x600000c8c540&gt;{number = 3, name = (null)}
2019-04-01 14:19:29.398409+0800 LockTest[4435:147099] 剩余票数:2, Thread:&lt;NSThread: 0x600000c8c540&gt;{number = 3, name = (null)}
2019-04-01 14:19:30.398952+0800 LockTest[4435:147099] 剩余票数:1, Thread:&lt;NSThread: 0x600000c8c540&gt;{number = 3, name = (null)}
2019-04-01 14:19:31.403696+0800 LockTest[4435:147099] 剩余票数:0, Thread:&lt;NSThread: 0x600000c8c540&gt;{number = 3, name = (null)}
2019-04-01 14:19:32.403928+0800 LockTest[4435:147099] 票已经卖完：Thread:&lt;NSThread: 0x600000c8c540&gt;{number = 3, name = (null)}
2019-04-01 14:19:33.405796+0800 LockTest[4435:147102] 票已经卖完：Thread:&lt;NSThread: 0x600000c8d040&gt;{number = 4, name = (null)}
</code></pre></blockquote>
<ul>
<li><strong>NSLock 互斥锁</strong>，不能多次调用lock方法，会造成死锁</li>
</ul>
<p>在Cocoa程序中NSLock实现了一个简单的互斥锁。<br>所有锁（包括NSLock）的接口实际上都是通过<code>NSLocking</code>定义的，它定义了<code>lock</code>和<code>unlock</code>方法，你使用这些方法获取或者释放该锁。</p>
<p>NSLock类还增加了<code>tryLock</code>和<code>lockBeforeDate</code>:方法。</p>
<ul>
<li><code>tryLock</code>试图获取一个锁，但是如果锁不可用的时候，它不会阻塞线程，相反，它只是返回NO。</li>
<li><code>lockBeforeDate:</code>方法试图获取一个锁，但是如果锁没有在规定的时间内被获得，它会让线程从阻塞状态变成非阻塞状态。（或者返回NO）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">-(void)startSaleTickets</span><br><span class="line">&#123;</span><br><span class="line">    _tickets = 5;//设置票的总数</span><br><span class="line">    dispatch_async(_saleticket_queue, ^&#123;</span><br><span class="line">        [self saleTickets];</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(_saleticket_queue, ^&#123;</span><br><span class="line">        [self saleTickets];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//@synchronized</span><br><span class="line">-(void)saleTickets</span><br><span class="line">&#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        @synchronized (self) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:1];</span><br><span class="line">            if (_tickets &gt; 0) &#123;</span><br><span class="line">                _tickets -- ;</span><br><span class="line">                NSLog(@&quot;剩余票数:%d, Thread:%@&quot;,_tickets,[NSThread currentThread]);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                NSLog(@&quot;票已经卖完：Thread:%@&quot;,[NSThread currentThread]);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印如下</p>
<blockquote>
<pre><code>2019-04-01 14:53:04.285814+0800 LockTest[4552:172571] 剩余票数:4, Thread:&lt;NSThread: 0x60000320d940&gt;{number = 3, name = (null)}
2019-04-01 14:53:06.584844+0800 LockTest[4552:172572] 剩余票数:3, Thread:&lt;NSThread: 0x60000320d7c0&gt;{number = 4, name = (null)}
2019-04-01 14:53:07.585406+0800 LockTest[4552:172571] 剩余票数:2, Thread:&lt;NSThread: 0x60000320d940&gt;{number = 3, name = (null)}
2019-04-01 14:53:08.443847+0800 LockTest[4552:172572] 剩余票数:1, Thread:&lt;NSThread: 0x60000320d7c0&gt;{number = 4, name = (null)}
2019-04-01 14:53:10.613102+0800 LockTest[4552:172571] 剩余票数:0, Thread:&lt;NSThread: 0x60000320d940&gt;{number = 3, name = (null)}
2019-04-01 14:53:12.610755+0800 LockTest[4552:172572] 票已卖完，Thread：&lt;NSThread: 0x60000320d7c0&gt;{number = 4, name = (null)}
2019-04-01 14:53:13.614076+0800 LockTest[4552:172571] 票已卖完，Thread：&lt;NSThread: 0x60000320d940&gt;{number = 3, name = (null)}
</code></pre></blockquote>
<ul>
<li>NSRecursiveLock 递归锁<br>使用递归锁最容易犯的一个错误就是在<strong>递归或循环中造成死锁</strong><br>如下代码中，因为在线程1中的递归block中，锁会被多次lock，所以自己也被阻塞了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-(void)deadLockTest</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_async(_saleticket_queue, ^&#123;</span><br><span class="line">        static void(^LockTest)(int);</span><br><span class="line">        LockTest = ^(int value)&#123;</span><br><span class="line">            [self-&gt;_lock lock];</span><br><span class="line">            if (value &gt; 0) &#123;</span><br><span class="line">                [NSThread sleepForTimeInterval:1];</span><br><span class="line">                NSLog(@&quot;deadLockTest Value=%d&quot;,value);</span><br><span class="line">                LockTest(value--);</span><br><span class="line">            &#125;</span><br><span class="line">            [self-&gt;_lock unlock];</span><br><span class="line">        &#125;;</span><br><span class="line">        LockTest(5);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处，将NSLock换成NSRecursizeLock便解决问题.<br>NSRecursiveLock类定义的锁可以在同一线程多次lock，而不会造成死锁。递归锁会跟踪它被多次次lock。每次成功的lock都必须平衡调用unlock操作。只有所有的锁住和解锁操作都平衡的时候，锁才真正被释放给其他线程获得。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">-(void)recursizeLockTest</span><br><span class="line">&#123;</span><br><span class="line">    _recursizeLock = [[NSRecursiveLock alloc] init];</span><br><span class="line">    dispatch_async(_saleticket_queue, ^&#123;</span><br><span class="line">        static void(^TestLock)(int);</span><br><span class="line">        TestLock = ^(int value)&#123;</span><br><span class="line">            [self-&gt;_recursizeLock lock];</span><br><span class="line">            if (value &gt; 0) &#123;</span><br><span class="line">                [NSThread sleepForTimeInterval:1];</span><br><span class="line">                NSLog(@&quot;recursizeLockTest Value=%d&quot;,value);</span><br><span class="line">                value--;</span><br><span class="line">                TestLock(value);</span><br><span class="line">            &#125;</span><br><span class="line">            [self-&gt;_recursizeLock unlock];</span><br><span class="line">        &#125;;</span><br><span class="line">        TestLock(5);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>NSConditionLock 条件锁</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-(void)condictionLockTest</span><br><span class="line">&#123;</span><br><span class="line">    NSConditionLock  *theLock = [[NSConditionLock alloc] init];</span><br><span class="line">    //线程1</span><br><span class="line">    dispatch_async(_saleticket_queue, ^&#123;</span><br><span class="line">        for (int i=0; i&lt;= 3; i++)&#123;</span><br><span class="line">            [theLock lock];</span><br><span class="line">            NSLog(@&quot;thread:%d&quot;,i);</span><br><span class="line">            sleep(1);</span><br><span class="line">            [theLock unlockWithCondition:i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    //线程2</span><br><span class="line">    dispatch_async(_saleticket_queue, ^&#123;</span><br><span class="line">        [theLock lockWhenCondition:2];</span><br><span class="line">        NSLog(@&quot;thread2111111&quot;);</span><br><span class="line">        [theLock unlock];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在线程1中加锁使用了lock，是不需要条件的，所以顺利的就锁住了,unlockWithConditin:在开锁的同时设置了一个整形条件2.线程2則需要一把被标识为2的钥匙，所以当线程1循环到i=2时，线程2的任务才执行。<br>NSConditionLock也跟其他的锁一样，是需要lock与unlock对应的，只是lock，lockWhenCondition:与unlock，unlockWithCondition:是可以随意组合的。当然这是与你需求相关的。</p>
<ul>
<li>pthread_mutex 互斥锁</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (void)pthread_mutexTest</span><br><span class="line">&#123;</span><br><span class="line">    __block pthread_mutex_t mutex;</span><br><span class="line">    pthread_mutex_init(&amp;mutex, NULL);</span><br><span class="line">    //线程1</span><br><span class="line">    dispatch_async(_saleticket_queue, ^&#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        NSLog(@&quot;任务1&quot;);</span><br><span class="line">        sleep(2);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;);</span><br><span class="line">    //线程2</span><br><span class="line">    dispatch_async(_saleticket_queue, ^&#123;</span><br><span class="line">        sleep(1);</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        NSLog(@&quot;任务2&quot;);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印如下</p>
<blockquote>
<pre><code>2019-04-01 17:28:03.606464+0800 LockTest[5075:272170] 任务1
2019-04-01 17:28:05.611833+0800 LockTest[5075:272169] 任务2
</code></pre></blockquote>
<ul>
<li>dispatch_semaphore 信号量实现加锁</li>
</ul>
<p>GCD也提供了一种信号机制。使用它我们也可以来构建一把“锁”（从本质意义上来讲，信号量与锁是有区别的）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)dispatch_semaphoreTest</span><br><span class="line">&#123;</span><br><span class="line">    //创建信号量</span><br><span class="line">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);</span><br><span class="line">    //线程1</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">        NSLog(@&quot;任务1&quot;);</span><br><span class="line">        sleep(10);</span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">        sleep(1);</span><br><span class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">        NSLog(@&quot;任务2&quot;);</span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印如下:</p>
<blockquote>
<pre><code>2019-04-01 17:33:14.204755+0800 LockTest[5090:275909] 任务1
2019-04-01 17:33:24.206795+0800 LockTest[5090:275911] 任务2
</code></pre></blockquote>
<p><strong>信号量和互斥锁的区别</strong></p>
<p>信号量用在多线程任务同步的，一个线程完了某一个动作就通过信号量来告诉被的线程，别的线程再进行某些动作（大家都在semtake的时候，就阻塞在哪里）。而互斥锁是用在多线程多任务互斥的，一个线程占用了某一个资源，那么别的线程就无法访问，直到这个线程unlock，其他的线程才能开始利用这个资源。比如全局变量的访问，有时要加锁，操作完了再解锁。有时候锁和信号量会同时使用的。<br>也就是说，信号量不一定是锁定某一个资源，而是流程上的概念，比如有A、B两个线程，B线程要等A线程完成某一个任务以后再进行自己下面的步骤，这个任务不一定是锁定某一资源，还是可以进行一些计算或者数据处理之类。而线程互斥则是“锁住某一资源的概念”，在锁定期间内，其他线程无法对被保护的数据进行操作。有些情况下两者可以互换。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/01/lock/" data-id="cju7n6mn8000brab7jfqyy4b0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS中的锁信号量和互斥锁的区别-synchronized/">iOS中的锁	信号量和互斥锁的区别  @synchronized</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/04/02/swift/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Swift 相关面试题
        
      </div>
    </a>
  
  
    <a href="/2019/04/01/GCD/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">iOS 多线程实现 --GCD使用详解</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/NSDictionary的内部实现原理/">NSDictionary的内部实现原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Swift/">Swift</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS/">iOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS中的锁信号量和互斥锁的区别-synchronized/">iOS中的锁	信号量和互斥锁的区别  @synchronized</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构相关定义/">数据结构相关定义</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/NSDictionary的内部实现原理/" style="font-size: 10px;">NSDictionary的内部实现原理</a> <a href="/tags/Swift/" style="font-size: 10px;">Swift</a> <a href="/tags/iOS/" style="font-size: 10px;">iOS</a> <a href="/tags/iOS中的锁信号量和互斥锁的区别-synchronized/" style="font-size: 10px;">iOS中的锁	信号量和互斥锁的区别  @synchronized</a> <a href="/tags/数据结构相关定义/" style="font-size: 10px;">数据结构相关定义</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/04/06/data_struct/">数据结构的一些定义</a>
          </li>
        
          <li>
            <a href="/2019/04/04/CocosPod/">CocosPod 错误</a>
          </li>
        
          <li>
            <a href="/2019/04/02/swift/">Swift 相关面试题</a>
          </li>
        
          <li>
            <a href="/2019/04/01/lock/">iOS中几种常用的锁</a>
          </li>
        
          <li>
            <a href="/2019/04/01/GCD/">iOS 多线程实现 --GCD使用详解</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 ZQing<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>