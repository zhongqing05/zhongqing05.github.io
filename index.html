<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>黑夜传说</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="踩过的坑，留一个脚印。只为了下次的到来能绕道而行">
<meta name="keywords" content="Object-C 、Swift">
<meta property="og:type" content="website">
<meta property="og:title" content="黑夜传说">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="黑夜传说">
<meta property="og:description" content="踩过的坑，留一个脚印。只为了下次的到来能绕道而行">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="黑夜传说">
<meta name="twitter:description" content="踩过的坑，留一个脚印。只为了下次的到来能绕道而行">
  
    <link rel="alternate" href="/atom.xml" title="黑夜传说" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">黑夜传说</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">机会都是留给有准备的人！</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-fanxing" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/05/fanxing/" class="article-date">
  <time datetime="2019-05-04T16:10:21.061Z" itemprop="datePublished">2019-05-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/05/fanxing/">泛型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>泛型代码让你能够自定义要求，编写出适用于任意类型、灵活可重用的函数及类型。它能够让你避免代码重复，用一种清晰抽象的方式来表达意图。</p>
<h4 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func swapTwoValues&lt;T&gt;(_ a: inout T, _ b: inout T)&#123;</span><br><span class="line">	let temporaryA = a</span><br><span class="line">	a = b</span><br><span class="line">	b = temporaryA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><t>这个尖括号告诉Swift那个T是swapTwoValues函数定义的一个占位类型名，因此Swift不会去查找名为T的实际类型</t></p>
<h5 id="类型参数"><a href="#类型参数" class="headerlink" title="类型参数"></a>类型参数</h5><p>你可以提供多个类型参数，将他们都写在尖括号中，用逗号隔开</p>
<h5 id="命名类型参数"><a href="#命名类型参数" class="headerlink" title="命名类型参数"></a>命名类型参数</h5><p>大多数情况下，命名参数具有一个描述性名字，例如 Dictionary&lt;Key, Value&gt; 中的Key和Value，以及Array<element>中的Element</element></p>
<h4 id="泛型类型"><a href="#泛型类型" class="headerlink" title="泛型类型"></a>泛型类型</h4><p>除了泛型函数，Swift还允许你定义泛型类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct Stack&lt;Element&gt; &#123;</span><br><span class="line">	var items = [Element]()</span><br><span class="line">	mutating func push(_ item: Element)&#123;</span><br><span class="line">		items.append(item)</span><br><span class="line">	&#125;</span><br><span class="line">	mutating func pop() -&gt; Element &#123;</span><br><span class="line">		return items.removeLast()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Element 为待提供的类型定义了一个占位名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var stackOfString = Stack&lt;String&gt;()</span><br><span class="line">stackOfString.push(&quot;uno&quot;)</span><br><span class="line">stackOfString.push(&quot;dos&quot;)</span><br><span class="line">stackOfString.push(&quot;tres&quot;)</span><br><span class="line"></span><br><span class="line">let fromThePop = stackOfStirng.pop()</span><br></pre></td></tr></table></figure>
<h5 id="扩展一个泛型类型"><a href="#扩展一个泛型类型" class="headerlink" title="扩展一个泛型类型"></a>扩展一个泛型类型</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">extension Stack &#123;</span><br><span class="line">	var topItems: Element? &#123;</span><br><span class="line">		return items.isEmpty ? nil : items[items.count -1]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//这个扩展并没有定义一个类型参数列表。相反的，Stack类型已有的类型参数名称Element，</span><br><span class="line">被用在扩展中表示计算型topItems的可选类型。</span><br><span class="line"></span><br><span class="line">if let topItem = stackOfString.topItem &#123;</span><br><span class="line">	print(&quot;The top item on the stack is \(topItem)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类型约束"><a href="#类型约束" class="headerlink" title="类型约束"></a>类型约束</h4><p>类型约束是指定一个类型参数必须继承指定类，或者符合一个特定的协议或协议组合。例如，Swift中的Dictionary类型对字典的键类型做了限制。字典的键必须是可哈希（hashable）的。</p>
<h5 id="类型约束语法"><a href="#类型约束语法" class="headerlink" title="类型约束语法"></a>类型约束语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func someFunction&lt;T: SomeClass, U: SomeProtocol&gt;(someT: T, someU: U)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="类型约束实践"><a href="#类型约束实践" class="headerlink" title="类型约束实践"></a>类型约束实践</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func findIndex&lt;T&gt;(of valueToFind: T, in array:[T]) -&gt; Int? &#123;</span><br><span class="line">	for (index, value) in array.enumerated() &#123;</span><br><span class="line">		if value == valueToFind&#123;</span><br><span class="line">			return index</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面所写的函数无法通过编译。问题出在相等性检查上。不是所有的Swift类型都可以用等式符进行比较。Swift标准库中定义了一个Equatalbe协议。该协议要求任何遵循的类型必须实现等式符（==）及不等符（!=）,从而能对改类型的任意两个值进行比较</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func findIndex&lt;T: Equatable&gt;(of valueToFind: T, in array: [T]) -&gt; Int ? &#123;</span><br><span class="line">	for (index, value) in array.enumerated() &#123;</span><br><span class="line">		if value == valueToFind &#123;</span><br><span class="line">			return index</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="关联类型"><a href="#关联类型" class="headerlink" title="关联类型"></a>关联类型</h4><p>关联类型为协议中的某个类型提供一个占位名，其代表的实际类型在协议被采纳时才会被指定。你可以通过 associatedtype关键字来指定关联类型。</p>
<h5 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//定义一个Container 协议，该协议定义了一个关联类型Item</span><br><span class="line">protocol Container &#123;</span><br><span class="line">	associatedtype Item</span><br><span class="line">	mutating func append(_ item: Item)</span><br><span class="line">	var count: Int &#123; get &#125;</span><br><span class="line">	subscript(i: Int) -&gt; Item &#123; get &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义一个非泛型的IntStack类型。采纳并符合了Container协议</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">struct IntStack: Container &#123;</span><br><span class="line">	//原始实现</span><br><span class="line">	var items = [Int]()</span><br><span class="line">	mutating func push(_ item: Int)&#123;</span><br><span class="line">		items.append(item)</span><br><span class="line">	&#125;</span><br><span class="line">	mutating func pop() -&gt; Int &#123;</span><br><span class="line">		return items.removeLast()</span><br><span class="line">	&#125;</span><br><span class="line">	//Container 协议实现部分</span><br><span class="line">	typealias Item = Int </span><br><span class="line">	mutating func append(_ item: Int)&#123;</span><br><span class="line">		self.push(item)</span><br><span class="line">	&#125;</span><br><span class="line">	var count: Int &#123;</span><br><span class="line">		return items.count</span><br><span class="line">	&#125;</span><br><span class="line">	subscript(i: Int) -&gt; Int &#123;</span><br><span class="line">		return items[i]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>指定Item为Int类型，即typealias Item = Int,从而将Container协议中抽象的Item类型转换为具体的Int类型</p>
<p>下面定义泛型Stack结构体并且遵循Container协议</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">struct Stack&lt;Element&gt;: Container&#123;</span><br><span class="line">	//Stack&lt;Element&gt; 的原始实现部分</span><br><span class="line">	var items = [Element]()</span><br><span class="line">	mutating func push(_ item: Element)&#123;</span><br><span class="line">		items.append(item)</span><br><span class="line">	&#125;</span><br><span class="line">	mutating func pop() -&gt; Element &#123;</span><br><span class="line">		return items.removeLast()</span><br><span class="line">	&#125;</span><br><span class="line">	//Container  协议实现部分</span><br><span class="line">	mutating func append(_ item: Element)&#123;</span><br><span class="line">		self.push(item)</span><br><span class="line">	&#125;</span><br><span class="line">	var count: Int &#123;</span><br><span class="line">		return items.count</span><br><span class="line">	&#125;</span><br><span class="line">	subscript(i: Int) -&gt; Element&#123;</span><br><span class="line">		return items[i]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="通过扩展一个已经存在的类型来指定关联类型"><a href="#通过扩展一个已经存在的类型来指定关联类型" class="headerlink" title="通过扩展一个已经存在的类型来指定关联类型"></a>通过扩展一个已经存在的类型来指定关联类型</h5><p>Swift的Array类型已经提供了Container协议所有的属于、方法、以及下标的实现。这意味着你只需要简单的申明Array采纳协议就可以扩展Array</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extension Array: Container &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>定义了这个扩展之后，你可以将任意的Array当做Container</p>
<h5 id="给关联类型添加约束"><a href="#给关联类型添加约束" class="headerlink" title="给关联类型添加约束"></a>给关联类型添加约束</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">protocol Container &#123;</span><br><span class="line">	associatedtype Item: Equatable</span><br><span class="line">	mutating func append(_ item: Item)</span><br><span class="line">	var count: Int &#123; get &#125;</span><br><span class="line">	subscript(i: Int)-&gt; Item &#123; get &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了遵循Container协议，Item类型也必须遵循Equatable协议</p>
<h5 id="在关联类型约束里使用协议"><a href="#在关联类型约束里使用协议" class="headerlink" title="在关联类型约束里使用协议"></a>在关联类型约束里使用协议</h5><p>协议可以作为自身的要求出现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protocol SuffixableContainer : Container &#123;</span><br><span class="line">	associatedtype Suffix: SuffixableContainer where Suffix.Item == Item</span><br><span class="line">	func suffix(_ size: Int) -&gt; Suffix</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个协议中的Suffix是个关联类型。它有2个约束。它必须遵循SuffixableContainer协议（就是当前定义的协议），以及它的Item类型必须和容器里的Item类型相同</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">extension Stack: SuffixableContainer &#123;</span><br><span class="line">	func suffix(_ size: Int) -&gt; Stack &#123;</span><br><span class="line">		var result = Stack&lt;Int&gt;()</span><br><span class="line">		for index in (count-size)..&lt;count &#123;</span><br><span class="line">			result.append(self[index])</span><br><span class="line">		&#125;</span><br><span class="line">		return result </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="泛型Where语句"><a href="#泛型Where语句" class="headerlink" title="泛型Where语句"></a>泛型Where语句</h4><p>类型约束让你能够为泛型函数，下标，类型的类型参数定义一些强制要求。where子句跟一个或多个针对关联类型的约束，以及一个或多个类型参数和关联类型间的相等关系</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func allItemsMatch&lt;C1: Container, C2: Container&gt;(_ someContainer: C1, _ anotherContainer: C2) -&gt; Bool where C1.Item == C2.Item, C1.Item: Equatable &#123;</span><br><span class="line">  //检查容器是否相同</span><br><span class="line">  if someContainer.count != anotherContainer.count &#123;</span><br><span class="line">  return false</span><br><span class="line">  &#125;</span><br><span class="line">  //检查每一对元素是否相等</span><br><span class="line">  for i in 0..&lt;someContainer.count &#123;</span><br><span class="line">    if someContainer[i] != anotherContainer[i] &#123;</span><br><span class="line">    	return false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  //所有元素都匹配，返回true</span><br><span class="line">  return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数参数列表的两个类型的要求</p>
<ol>
<li>C1必须符合 Container 协议</li>
<li>C2必须符合 Container 协议</li>
<li>C1的Item和C2的Item类型相同</li>
<li>C1的Item必须符合Equatable协议</li>
</ol>
<h5 id="具有泛型Where子句的扩展"><a href="#具有泛型Where子句的扩展" class="headerlink" title="具有泛型Where子句的扩展"></a>具有泛型Where子句的扩展</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">extension Stack where Element: Equatalbe &#123;</span><br><span class="line">	func isTop(_ item: Element) -&gt; Bool &#123;</span><br><span class="line">		guard let topItem = items.last else&#123;</span><br><span class="line">			return false</span><br><span class="line">		&#125;</span><br><span class="line">		return topItem == item</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>//如果尝试在其元素不符合Equatable协议栈上调用isTop(_:)方法，则会编译报错</p>
<p><strong>使用where字句去扩展一个协议</strong></p>
<p>where子句要求Item符合协议</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">extension Container where Item: Equatable &#123;</span><br><span class="line">	func startsWith(_ item: Item) -&gt; Bool &#123;</span><br><span class="line">		return count &gt; 1 &amp;&amp; self[0] == item</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if [8, 9, 9].statsWith(43)&#123;</span><br><span class="line">	print(&quot;Start Wiht 43&quot;)</span><br><span class="line">&#125;else &#123;</span><br><span class="line">	print(&quot;Start with something else&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>where字句要求Item为特定的类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">extension Container where Item == Double &#123;</span><br><span class="line">	func average() -&gt; Double &#123;</span><br><span class="line">		var sum = 0.0;</span><br><span class="line">		for index in 0..&lt;count &#123;</span><br><span class="line">			sum += self[index]</span><br><span class="line">		&#125;</span><br><span class="line">		return sum / Double(count)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">print([125.0, 23.00, 323.00].average())</span><br></pre></td></tr></table></figure>
<h5 id="具有泛型Where字句的关联类型"><a href="#具有泛型Where字句的关联类型" class="headerlink" title="具有泛型Where字句的关联类型"></a>具有泛型Where字句的关联类型</h5><p>你可以在关联类型后面加上具有泛型where的子句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">protocol Container &#123;</span><br><span class="line">	associatedtype Item</span><br><span class="line">	mutating func append(_ item: Item)</span><br><span class="line">	var count: Int &#123; get &#125;</span><br><span class="line">	subscript(i: Int) -&gt; Item &#123; get &#125;</span><br><span class="line">	associatedtype Iterator: IteratorProtocol where Iterator.Element == Item</span><br><span class="line">	func makeIterator() -&gt; Iterator</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代器（Iterator）的泛型where字句要求，无论迭代器是什么类型，迭代器中的元素必须和容器项目的类型保持一致</p>
<h5 id="泛型下标"><a href="#泛型下标" class="headerlink" title="泛型下标"></a>泛型下标</h5><p>下标是能够泛型的，他们能够包含泛型where子句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">extension Container &#123;</span><br><span class="line">	subscript&lt;Indices: Sequence&gt;(indices: Indices) -&gt; [Item] where Indices.Iterator.Element == Int &#123;</span><br><span class="line">		var result = [Item]()</span><br><span class="line">		for index in indices &#123;</span><br><span class="line">			result.append(self[index])</span><br><span class="line">		&#125;</span><br><span class="line">		return result</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/05/05/fanxing/" data-id="cjvlqkh6c000ouib8vmnhpa99" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Swift/">Swift</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Protocol" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/30/Protocol/" class="article-date">
  <time datetime="2019-04-30T06:36:55.014Z" itemprop="datePublished">2019-04-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/30/Protocol/">协议</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>协议定义了一个蓝图，规定了用来实现某一特定任务或者功能的方法、属性、以及其他需要的东西。</p>
<p>协议的语法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protocol SomeProtocol &#123;</span><br><span class="line">	//协议的定义部分</span><br><span class="line">&#125;</span><br><span class="line">//某个自定义类型遵循协议</span><br><span class="line">struct SomeStructure : SomeProtocol, AnotherProtocol &#123;</span><br><span class="line">&#125;</span><br><span class="line">拥有父类的类在遵循协议时，应该将父类名放在协议名之前</span><br><span class="line">class SomeClass : SomeSuperClass, FirstProtocol, AnotherProtocol &#123;</span><br><span class="line">	// 这里是类的定义部分</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="属性要求"><a href="#属性要求" class="headerlink" title="属性要求"></a>属性要求</h4><p>协议可以要求遵循的类型提供特定名称和类型的实例属性或类型属性。协议不知道是存储属性还是计算属性，它指定属性的名称和类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">protocol SomeProtocol &#123;</span><br><span class="line">	var mustBeSetterble: Int &#123; get set&#125;</span><br><span class="line">	var doseNotNeedToBeSettable: Int &#123;get&#125;</span><br><span class="line">&#125;</span><br><span class="line">协议定义类型属性时，总是使用static关键字做前缀。当类类型遵循协议时，除了static关键字，还可以使用class关键字来声明类型属性</span><br><span class="line"></span><br><span class="line">protocol AnotherProtocol &#123;</span><br><span class="line">	static var someTypeProtocol: Int &#123; get set&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//遵循次协议必须有一个可读String类型的实例属性fullName</span><br><span class="line">protocl FullyName &#123;</span><br><span class="line">	var fullName: String &#123; get &#125;</span><br><span class="line">&#125;</span><br><span class="line">struct Person: FullyNamed &#123;</span><br><span class="line">	var fullName: String</span><br><span class="line">&#125;</span><br><span class="line">let john = Person(fullName: &quot;John&quot;)</span><br><span class="line">//john.fullName 为 “John”</span><br><span class="line"></span><br><span class="line">class StarShip: FullyNamed &#123;</span><br><span class="line">	var prefix: String?</span><br><span class="line">	var name: String</span><br><span class="line">	init(name: String, prefix: String? = nil)&#123;</span><br><span class="line">		self.name = name</span><br><span class="line">		self.prefix = prefix</span><br><span class="line">	&#125;</span><br><span class="line">	var fullName: String &#123;</span><br><span class="line">		return (prefix != nil ? prefix! + &quot;&quot;:&quot;&quot;) + name</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法要求"><a href="#方法要求" class="headerlink" title="方法要求"></a>方法要求</h4><p>在协议中定义类方法的时候，总是使用static 关键字作为前缀。当类类型遵循协议时，除了static关键字，还可以使用class关键字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protocol SomeProtocol &#123;</span><br><span class="line">	static func someTypeMethod()</span><br><span class="line">&#125;</span><br><span class="line">//定义一个只含有实例方法的协议</span><br><span class="line">protocol RandomNumberGenerator &#123;</span><br><span class="line">	func someFun() -&gt; Int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="异变方法要求"><a href="#异变方法要求" class="headerlink" title="异变方法要求"></a>异变方法要求</h5><p>有时候需要在方法中改变方法所属的实例。例如，在值类型的实例方法中，将<code>mutating</code>关键字作为方法的前缀，写在func关键字之前，表示可以在该方法中修改所属的实例以及实例任意属性的值。</p>
<p><strong>注意：</strong><br>实现协议中的mutating方法时，若是类类型，则不用写mutating关键字。而对于结构体和枚举，则必须mutating关键字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">protocol Togglable &#123;</span><br><span class="line">	mutating func toggle()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum OnOffSwitch: Togglable &#123;</span><br><span class="line">	cass off , on</span><br><span class="line">	mutating func toggle()&#123;</span><br><span class="line">		switch self &#123;</span><br><span class="line">		case .off</span><br><span class="line">			self = .on</span><br><span class="line">		case .on </span><br><span class="line">			self = .off</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">var lightSwitch = OnOffSwitch.off</span><br><span class="line">lightSwitch.toggle()</span><br><span class="line">//lightSwitch 现在是 .on</span><br></pre></td></tr></table></figure>
<h5 id="构造器要求"><a href="#构造器要求" class="headerlink" title="构造器要求"></a>构造器要求</h5><p>协议可以要求遵循协议类型实现指定构造器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protocol SomeProtocol &#123;</span><br><span class="line">	init(someParameter: Int)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="协议构造器要求的类实现"><a href="#协议构造器要求的类实现" class="headerlink" title="协议构造器要求的类实现"></a>协议构造器要求的类实现</h5><p>你可以遵循协议的类中实现构造器，无论作为指定构造器还是便利构造器，都必须为构造器标上required修饰符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class SomeClass : SomeProtocol &#123;</span><br><span class="line">	required init(someParameter: Int)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">//required 修饰符可以确保所有子类也必须提供此构造器实现，从而也能符合协议。</span><br><span class="line">//如果类已经标记为final，那么不需要在协议构造器的实现中使用required修饰符。因为final类不能有子类</span><br><span class="line"></span><br><span class="line">//如果一个子类重写了父类的指定构造器，并且该构造器满足了某个协议的要求，那么该构造器的实现需要同时标注 required 和 override</span><br><span class="line"></span><br><span class="line">protocol SomeProtocol&#123;</span><br><span class="line">   init()</span><br><span class="line">&#125;</span><br><span class="line">class SomeSuperClass&#123;</span><br><span class="line">	init()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class SomeSubClass: SomeSuperClass, SomeProtocol &#123;</span><br><span class="line">	//因为遵循协议，需要加上required</span><br><span class="line">	//因为继承自父类，需要加上override</span><br><span class="line">	required override init()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="可失败构造器要求"><a href="#可失败构造器要求" class="headerlink" title="可失败构造器要求"></a>可失败构造器要求</h5><p>协议还可为遵循协议类型的类型定义可失败构造器</p>
<h4 id="协议作为类型"><a href="#协议作为类型" class="headerlink" title="协议作为类型"></a>协议作为类型</h4><p>协议本身并不实现任何功能，但是协议可以被当做一个成熟的类型来使用。协议可以像其他普通类型一样使用。</p>
<ul>
<li>作为函数、方法或构造器中的参数类型或返回值类型</li>
<li>作为常量、变量或属性的类型</li>
<li>作为数组、字典或其他容器的元素类型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">protocol RandomNumberGenerator &#123;</span><br><span class="line">	func random() -&gt; Double</span><br><span class="line">&#125;</span><br><span class="line">class Dice &#123;</span><br><span class="line">	let sides: Int</span><br><span class="line">	let generator: RandomNumberGenerator</span><br><span class="line">	init(sides: Int, generator: RandomNumberGenerator)&#123;</span><br><span class="line">		self.sides = sides</span><br><span class="line">		self.generator = generator</span><br><span class="line">	&#125;</span><br><span class="line">	func roll() -&gt; Int &#123;</span><br><span class="line">		return Int(generator.random * Double(sides))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="委托-现实中最常见的用法"><a href="#委托-现实中最常见的用法" class="headerlink" title="委托 现实中最常见的用法"></a>委托 现实中最常见的用法</h4><p>委托是一种设计模式，它允许类或结构体将一些需要它们负责的功能委托给其他类型的实例。</p>
<h4 id="在扩展里添加协议遵循"><a href="#在扩展里添加协议遵循" class="headerlink" title="在扩展里添加协议遵循"></a>在扩展里添加协议遵循</h4><p>扩展可以为已有类型添加属性（计算属性）、方法、下标以及构造器，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extersion SomeClass: SomeProtocol &#123;</span><br><span class="line">	//实现遵循的协议</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="有条件地遵循协议"><a href="#有条件地遵循协议" class="headerlink" title="有条件地遵循协议"></a>有条件地遵循协议</h4><p>泛型类型可能只在某些情况下满足一个协议的要求，比如当类类型的泛型形式参数遵循对应协议时。你可以通过扩展类型列出限制泛型类型有条件的遵循某协议。在你采纳协议的名字后面写泛型where分句。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protocol SomeProtocol &#123;</span><br><span class="line">	var textOutput: String &#123; get &#125;</span><br><span class="line">&#125;</span><br><span class="line">extension Array : SomeProtocol where Element: String &#123;</span><br><span class="line">	//</span><br><span class="line">	var textOutput: String&#123;</span><br><span class="line">		let text = self.map &#123; $0.textOutput &#125;</span><br><span class="line">		return &quot;[&quot; + text + &quot;]&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="在扩展里声明采纳协议"><a href="#在扩展里声明采纳协议" class="headerlink" title="在扩展里声明采纳协议"></a>在扩展里声明采纳协议</h5><p>当一个类型已经符合了某个协议中的所有要求，却还没有声明采纳该协议时。可以通过空扩展体的扩展采纳该协议。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct Hamster &#123;</span><br><span class="line">	//完全实现了协议 SomeProtocol</span><br><span class="line">&#125;</span><br><span class="line">//这里显示的声明</span><br><span class="line">extersion Hamster : SomeProtocol&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>注意：即使满足了协议的所有要求，类型也不会自动遵循协议，必须显示地遵循协议</p>
<h5 id="协议类型的集合"><a href="#协议类型的集合" class="headerlink" title="协议类型的集合"></a>协议类型的集合</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//集合中的3个元素都遵循SomeProtocol协议的实例</span><br><span class="line">let things: [SomeProtocol] = [param1,param2,param3]</span><br></pre></td></tr></table></figure>
<h5 id="协议继承"><a href="#协议继承" class="headerlink" title="协议继承"></a>协议继承</h5><p>协议能够继承一个或多个其他协议</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protocol SomeProtocol: FirstProtocol,AnthorProtocol &#123;</span><br><span class="line">	//定义部分</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类专属的协议"><a href="#类专属的协议" class="headerlink" title="类专属的协议"></a>类专属的协议</h4><p>通过添加AnyObject 关键字到协议的继承列表，就可以限制协议只能被类类型采纳。<br>protocol SomeClassProtcol: class {<br>    //专属类的协议定义部分<br>}</p>
<h4 id="协议合成"><a href="#协议合成" class="headerlink" title="协议合成"></a>协议合成</h4><p>要求一个类型同时遵循多个协议是很有用的。你可以使用协议组合来复合多个协议到一个要求里。</p>
<p>协议组合使用 SomeProtocol &amp; AnotherProtocol 的形式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">protocol Named &#123;</span><br><span class="line">	var name: String &#123; get &#125;</span><br><span class="line">&#125;</span><br><span class="line">protocol Aged &#123;</span><br><span class="line">	var age: Int &#123; get &#125;</span><br><span class="line">&#125;</span><br><span class="line">struct Person: Named, Aged &#123;</span><br><span class="line">	var name: String</span><br><span class="line">	var age: Int</span><br><span class="line">&#125;</span><br><span class="line">//函数参数 celebrator 类型为 Name &amp; Aged。这意味着同时要遵循这2个协议</span><br><span class="line">func wishHappyBirthday(to celebrator: Name &amp; Aged)&#123;</span><br><span class="line">	 print(&quot;Happy birthday, \(celebrator.name), you&apos;re \(celebrator.age)!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Location &#123;</span><br><span class="line">&#125;</span><br><span class="line">class City: Location, Named &#123;</span><br><span class="line">&#125;</span><br><span class="line">//这意味这方法只接受 Location &amp; Named 的参数</span><br><span class="line">func beginConcert(in location: Location &amp; Named)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="检查协议一致性"><a href="#检查协议一致性" class="headerlink" title="检查协议一致性"></a>检查协议一致性</h4><p><code>is</code> 和<code>as</code>操作符来检查协议一致性，即是否复合某协议，并且可以转换到指定的协议类型。</p>
<ul>
<li>is 用来检查实例是否复合某个协议</li>
<li>as? 返回一个可选值，当实例复合某个协议是，返回类型为协议类型的可选值。</li>
<li>as! 将实例强制向下转换到某个协议，如果转换失败，会引发运行时错误</li>
</ul>
<h4 id="可选的协议要求"><a href="#可选的协议要求" class="headerlink" title="可选的协议要求"></a>可选的协议要求</h4><p>协议可以定义可选要求，遵循协议类型可以选择是否实现这些要求。协议中使用 <strong>optional</strong> 关键字作为前缀来定义可选要求。可选要求用在你需要和Objective-C打交道的代码中。协议和可选要求都必须带上 <code>@objc</code> 属性。标记 <code>@objc</code>特性的协议只能被继承自 Objective-C类或者遵循。</p>
<p>使用可选要求时，他们的类型会自动变成可选的。比如，一个类型为 (Int) -&gt; String 的方法会变成 ((Int) -&gt; String)? ，这里是函数类型可选，不是函数的返回值可选</p>
<h4 id="协议扩展"><a href="#协议扩展" class="headerlink" title="协议扩展"></a>协议扩展</h4><p>协议可以通过扩展来为遵循协议的类型提供属性、方法以及下标的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extension RandomNumberGenerator &#123;</span><br><span class="line">	func randomBool() -&gt; Bool &#123;</span><br><span class="line">		retrun random() &gt; 0.5</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过协议扩展，所有遵循协议的类型，都能自动获得这个扩展所增加的方法实现，无需任何额外的修改</p>
<h5 id="提供默认实现"><a href="#提供默认实现" class="headerlink" title="提供默认实现"></a>提供默认实现</h5><p>可以通过协议扩展来为协议的属性、方法以及下标提供默认的实现。如果遵循协议的类型为这些要求提供了自己的实现，那么这些自定义实现将会替代扩展的默认实现被使用。</p>
<h4 id="为协议扩展添加限制条件"><a href="#为协议扩展添加限制条件" class="headerlink" title="为协议扩展添加限制条件"></a>为协议扩展添加限制条件</h4><p>在扩展协议的时候，可以指定一些限制条件，只有遵循协议的类型满足某些限制条件，才能获得协议扩展提供的默认实现。使用<code>where</code>字句来描述</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">extension Collection where Element: Equatable &#123;</span><br><span class="line">	func allEqual() -&gt; Bool &#123;</span><br><span class="line">		for element in self &#123;</span><br><span class="line">			if element != self.first &#123;</span><br><span class="line">				return false </span><br><span class="line">			&#125;		</span><br><span class="line">		&#125;</span><br><span class="line">		return true</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/30/Protocol/" data-id="cjvlqkh61000auib8jmnuhw08" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Swift/">Swift</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-extension" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/28/extension/" class="article-date">
  <time datetime="2019-04-28T12:28:53.957Z" itemprop="datePublished">2019-04-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/28/extension/">扩展</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>扩展就是为一个已有的类、结构体、枚举或者协议添加新功能。</p>
<p>Swift中的扩展</p>
<ul>
<li>添加计算型属性和计算型类型属性</li>
<li>定义实例方法和类方法</li>
<li>提供新的构造器</li>
<li>定义下标</li>
<li>定义和使用新的嵌套类型</li>
<li>使一个已有类型符合某个协议</li>
</ul>
<h4 id="扩展语法"><a href="#扩展语法" class="headerlink" title="扩展语法"></a>扩展语法</h4><p>使用关键字 <code>extension</code>来声明扩展</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extension SomeType &#123;</span><br><span class="line">	// 为 SomeType扩展的新功能写到这里</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过扩展一个已有类型，使其采纳一个或多个协议</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extension SomeType : SomeProtocol, AnotherProtocol &#123;</span><br><span class="line">	//协议实现写到这里</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="计算型属性"><a href="#计算型属性" class="headerlink" title="计算型属性"></a>计算型属性</h5><p>扩展可以为已有类型添加计算型实例属性和计算型类型属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">extension Double &#123;</span><br><span class="line">	var km: Double &#123; return self * 1000.0 &#125;</span><br><span class="line">	var m: Double &#123; return self &#125;</span><br><span class="line">	var cm: Double &#123; return self / 100.0 &#125;</span><br><span class="line">	var mm: Double &#123; return self / 1000.0 &#125;</span><br><span class="line">	var ft: Double &#123; return self / 3.28084 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let oneInch = 25.4.mm</span><br><span class="line">let aMarathon = 42.km + 19.5m</span><br></pre></td></tr></table></figure>
<h5 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h5><p>扩展可以为已有类型添加新的构造器。扩展能为类添加新的<strong>便利构造器</strong>，但不能为类添加新的指定构造器。指定构造器必须总是由原始的类来实现提供</p>
<p><strong>注意</strong><br>如果你使用扩展为一个值类型添加构造器，同时该值类型的原始实现中未定义任何指定构造器且所有存储属性提供了默认值，那么我们可以再扩展中的构造里调用默认构造器和逐一成员构造器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct Size &#123;</span><br><span class="line">	var width = 0.0, height = 0.0</span><br><span class="line">&#125;</span><br><span class="line">struct Point&#123;</span><br><span class="line">	var x = 0.0, y = 0.0</span><br><span class="line">&#125;</span><br><span class="line">struct Rect &#123;</span><br><span class="line">	var origin = Point()</span><br><span class="line">	var size = Size()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let defaultRect = Rect()</span><br><span class="line">let memberRect = Rect(origin: Point(x: 0.0, y: 2.0), size: Size(width: 5.0, height: 5.0 ))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">extension Rect &#123;</span><br><span class="line">	init(center: Point, size: Size) &#123;</span><br><span class="line">		let originX = center.x - size.width / 2</span><br><span class="line">		let orginY = center.y - size.height / 2</span><br><span class="line">		self.init(origin: Point(x: orginX, y: originY), size: size)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">let centerRect = Rect(center: Point(x: 4.0, y: 4.0), size: Size(x: 5.0, y: 5.0))</span><br></pre></td></tr></table></figure>
<h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><p>扩展可以为已有类型添加实例方法和类型方法</p>
<h5 id="可变实例方法"><a href="#可变实例方法" class="headerlink" title="可变实例方法"></a>可变实例方法</h5><p>通过扩展添加的实例方法也可以修改该实例本身。结构体和枚举类型中修改self或其属性方法方法必须将改实例方法标注<code>mutating</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">extension Int &#123;</span><br><span class="line">	mutating func square ()&#123;</span><br><span class="line">		return self * self</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">var someInt = 3</span><br><span class="line">somInt.square()</span><br></pre></td></tr></table></figure>
<h5 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h5><p>扩展可以为已有类型添加新下标</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">extension Int &#123;</span><br><span class="line">	subscript(digitIndex: Int) -&gt; Int &#123;</span><br><span class="line">		var decimalBase = 1</span><br><span class="line">		for _ in 0..&lt;digitIndex &#123;</span><br><span class="line">			decimalBase *= 10</span><br><span class="line">		&#125;</span><br><span class="line">		return (self / decimalBase) %10</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">746[0]</span><br></pre></td></tr></table></figure>
<h5 id="嵌套类型"><a href="#嵌套类型" class="headerlink" title="嵌套类型"></a>嵌套类型</h5><p>扩展可以为已有类型的类、结构体和枚举添加新的嵌套类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">extension Int &#123;</span><br><span class="line">	enum Kind &#123;</span><br><span class="line">		case negative, zero, positive</span><br><span class="line">	&#125;</span><br><span class="line">	var kind: Kind &#123;</span><br><span class="line">		switch self &#123;</span><br><span class="line">			case 0:</span><br><span class="line">				return .zero</span><br><span class="line">			case let x where x &gt; 0 :</span><br><span class="line">				return .positve</span><br><span class="line">			default:</span><br><span class="line">				reutrn .negative</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例子为Int添加了嵌套类型，这个名为Kind的枚举表示特定整数的类型。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/28/extension/" data-id="cjvlqkh67000fuib8ud651644" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Swift/">Swift</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-option" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/25/option/" class="article-date">
  <time datetime="2019-04-25T08:40:03.058Z" itemprop="datePublished">2019-04-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/25/option/">可选链 、错误处理、类型转换、嵌套类型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>可选链（Optional Chaining）式调用</strong>是一种可以在当前值为<code>nil</code>的可选值上请求和调用属性、方法及下标的方法。如果可选值有值，那么会调用成功；如果可选值是<code>nil</code>，那么调用将返回<code>nil</code></p>
<h5 id="使用可选链式调用代替强制展开"><a href="#使用可选链式调用代替强制展开" class="headerlink" title="使用可选链式调用代替强制展开"></a>使用可选链式调用代替强制展开</h5><p>通过调用的属性、方法或下标的可选值后面放一个问号 ‘？‘，可以定义一个可选链。这一点很像在可选值后面放一个叹号’!‘来强制展开它的值。它们主要的区别在于可选值为空时可选链式调用只会调用失败，然后强制展开会将触发运行时错误。</p>
<h5 id="可选链式调用定义模型"><a href="#可选链式调用定义模型" class="headerlink" title="可选链式调用定义模型"></a>可选链式调用定义模型</h5><p>通过使用可选链式调用可以调用多层属性、方法和下标。这样可以在复杂的模型中向下访问各种子属性，并且判断能否访问子属性的属性、方法或下标</p>
<h5 id="通过可选链式调用访问属性"><a href="#通过可选链式调用访问属性" class="headerlink" title="通过可选链式调用访问属性"></a>通过可选链式调用访问属性</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//这里没有去创建相关的类。</span><br><span class="line">let john = Person()</span><br><span class="line">if let roomCount = john.residence?.numberOfRooms &#123;</span><br><span class="line"></span><br><span class="line">&#125;else &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="通过可选链式调用方法"><a href="#通过可选链式调用方法" class="headerlink" title="通过可选链式调用方法"></a>通过可选链式调用方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if john.residence?.printNumberOfRooms() != nil &#123;</span><br><span class="line">	print(&quot;It was possible to print the number of rooms&quot;)</span><br><span class="line">&#125;else &#123;</span><br><span class="line">	print(&quot;It was not possible to print teh number of rooms&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="通过可选链式调用访问下标"><a href="#通过可选链式调用访问下标" class="headerlink" title="通过可选链式调用访问下标"></a>通过可选链式调用访问下标</h5><p>通过可选链式调用，我们可以在一个可选值上访问下标，并且判断下标调用是否成功。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if let firstRoomName = john.residence?[0].name &#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">//用可选链调用来赋值</span><br><span class="line">john.residence?[0] = Room(name: &quot;Bathroom&quot;)</span><br></pre></td></tr></table></figure>
<h5 id="链接多层可选链式调用"><a href="#链接多层可选链式调用" class="headerlink" title="链接多层可选链式调用"></a>链接多层可选链式调用</h5><p>可选通过连接多个可选链式调用在更深的模型层次中访问属性、方法以及下标。然而，多层可选链式调用不会增加返回可选值的可选层次。</p>
<p>通过可可选链式访问一个Int值，将返回Int？，无论使用了多层可选链式调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if let johnsStreet = john. john.residence?.address?.street &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>错误处理是响应错误以及从错误中恢复的过程。</p>
<h4 id="表示并抛出错误"><a href="#表示并抛出错误" class="headerlink" title="表示并抛出错误"></a>表示并抛出错误</h4><p>在Swift中，错误用符合<code>Error</code>协议的类型的值来表示。这个空协议表明该类型可以用于错误处理</p>
<p>Swift枚举类型尤为适合构建一组相关的错误状态，枚举的关联值还可以提供错误状态的额外信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum VendingMachineError : Error &#123;</span><br><span class="line">	case invalidSelection  		//选择无效</span><br><span class="line">	case insufficientFunds( coinsNeeded: Int)  //金额不足</span><br><span class="line">	case outOfStock 				//缺货</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抛出错误使用 <code>throw</code>关键字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throw  VendingMachineError.insufficientFunds(coinsNeeded: 5)</span><br></pre></td></tr></table></figure>
<h4 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h4><p>Swift中有4种处理错误的方式。你可以把函数抛出的错误传递给调用此函数的代码、用 do-catch 语句处理错误、 将错误作为可选类型、或者断言此错误根本就不会发生。</p>
<p>在调用一个能抛出错误的函数、方法或者构造器之前，加上 <code>try</code> 关键字，或者 try？ 或 try！ 这种变体。</p>
<h5 id="用-throwing函数-传递错误"><a href="#用-throwing函数-传递错误" class="headerlink" title="用 throwing函数 传递错误"></a>用 throwing函数 传递错误</h5><p>为了标识一个函数、方法或构造器可以抛出错误，在函数声明的参数列表之后加上 <code>throws</code> 关键字。一个标有 <code>throws</code>关键字的函数称做 <strong>throwing</strong>函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func canThrowErrors() throws -&gt; String</span><br></pre></td></tr></table></figure>
<p>一个throwing函数可以在其内部抛出错误，并将错误传递到函数被调用的作用域。</p>
<p><strong>注意：</strong>只有throwing 函数可以传递错误。任何在某个非throwing函数内部抛出的错误只能在函数内部处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func vend(name: String) throws &#123;</span><br><span class="line">	guard name.isEmpty else &#123;</span><br><span class="line">		throw VendingMachineError.invalidSelection</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为vend(name:)方法会传递出它抛出的任何错误。在你的代码中调用此方法要么直接处理这些错误（使用do-catch，try？或try！）；要么继续将错误传递下去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func buyFavouriteSnack(person: String, vendingMachine: VendingMachine) throws &#123;</span><br><span class="line">	try vendingMachine.vend(name: snackName)</span><br><span class="line">&#125;</span><br><span class="line">//将错误继续传递下去</span><br></pre></td></tr></table></figure>
<h5 id="用Do-Catch处理错误"><a href="#用Do-Catch处理错误" class="headerlink" title="用Do-Catch处理错误"></a>用Do-Catch处理错误</h5><p>如果在do子语句中的代码抛出了一个错误，这个错误会与catch子语句做匹配。从而决定哪条子句能处理它</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">	try expression </span><br><span class="line">	statements</span><br><span class="line">&#125; catch pattern 1 &#123;</span><br><span class="line">	statements</span><br><span class="line">&#125; catch pattern 2 where condition &#123;</span><br><span class="line">	statements</span><br><span class="line">&#125;</span><br><span class="line">如果do代码块有错误抛出，相应的执行会马上转移到catch子句中，并判断这个错误是否要继续传递下去。如果没有错误抛出，do子句中余下的语句会被执行</span><br></pre></td></tr></table></figure>
<h5 id="将错误转换成可选值"><a href="#将错误转换成可选值" class="headerlink" title="将错误转换成可选值"></a>将错误转换成可选值</h5><p>可以使用try？通过错误转换成一个可选值来处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func someThrowingFunction() throws -&gt; Int &#123;</span><br><span class="line">	//...</span><br><span class="line">&#125;</span><br><span class="line">let x = try? someThrowingFunction()</span><br><span class="line"></span><br><span class="line">let y: Int?</span><br><span class="line">do &#123;</span><br><span class="line">	y = try someThrowingFunction()</span><br><span class="line">&#125; catch &#123;</span><br><span class="line">	y = nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果someThrowingFunction() 抛出错误，x和y的值都是nil。否则x和y的值是函数的返回值。无论someThrowingFunction()的返回值是什么类型，x，y都是这个类型的可选类型。</p>
<h5 id="禁用错误传递"><a href="#禁用错误传递" class="headerlink" title="禁用错误传递"></a>禁用错误传递</h5><p>有时你知道某个throwing函数实际上运行时是不会抛出错误的，在这种情况下，你可以再表达式前面写try!来禁止用错误传递，这会把调用包装在一个不会有错误抛出的运行时断言中。如果有错误抛出，你会得到一个运行时错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let phone = try! loadImage(atPath: &quot;./Resources/John&quot;)</span><br></pre></td></tr></table></figure>
<h5 id="指定清理操作"><a href="#指定清理操作" class="headerlink" title="指定清理操作"></a>指定清理操作</h5><p>你可以使用 <code>defer</code>语句<strong>在即将离开当前代码块是执行一系列语句</strong>。该语句能执行一些必要清理工作。</p>
<p>defer语句块将代码的执行延迟到当前作用域退出之前。延迟执行的语句不能包含任何控制转换语句，例如break、return语句或是抛出一个错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func processFile(filename: String) throws &#123;</span><br><span class="line">	if exists(filename) &#123;</span><br><span class="line">		let file = open(filename)</span><br><span class="line">		defer &#123;</span><br><span class="line">			close(file)</span><br><span class="line">		&#125;</span><br><span class="line">		while let line = try fiel.readline() &#123;</span><br><span class="line">			// 处理文件</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>类型转换可以判定实例的类型，也可以将实例看做是其父类或者子类的实例。</p>
<p>类型转换在Swift中使用<code>is</code>和<code>as</code>操作符实现。你可以用这2个操作符去检查值的类型和转换它的类型，也可以用它来检查是否实现了某个协议</p>
<h5 id="为类型转换定义类的层次"><a href="#为类型转换定义类的层次" class="headerlink" title="为类型转换定义类的层次"></a>为类型转换定义类的层次</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class MediaItem &#123;&#125;</span><br><span class="line"></span><br><span class="line">class Movie: MediaItem &#123;&#125;</span><br><span class="line"></span><br><span class="line">class Song: MediaItem &#123;&#125;</span><br><span class="line"></span><br><span class="line">let library = [</span><br><span class="line">	Movie()</span><br><span class="line">	Song()</span><br><span class="line">]</span><br><span class="line">//数组 library 的类型被推断为[MediaItem]</span><br></pre></td></tr></table></figure>
<h5 id="检查类型"><a href="#检查类型" class="headerlink" title="检查类型"></a>检查类型</h5><p>用<code>is</code>来检查实例是否属于某个特定的子类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for item in  library &#123;</span><br><span class="line">	if item is Movie &#123;</span><br><span class="line">		// is Movie</span><br><span class="line">	&#125;else if item is Song &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h5><p>某类型的一个常量或变量可能在幕后实际上是属于一个子类。当确定这种情况时，你可以尝试向下转到它的子类型。用 <code>as?</code> 或 <code>as!</code></p>
<p>向下转型可能会失败。as？返回一个你试图向下转成的类型的可选类型。as！是试图向下转型和强制解包转换结果结为一体。如果失败会触发运行时错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for item in library &#123;</span><br><span class="line">	if let movie = item as? Movie &#123;</span><br><span class="line">		//is Movie</span><br><span class="line">	&#125;else if let song = item as? Song &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Any-和-AnyObject"><a href="#Any-和-AnyObject" class="headerlink" title="Any 和 AnyObject"></a>Any 和 AnyObject</h4><p>Swift 中提供了2中特殊的类型别名：</p>
<ul>
<li>Any 可以表示任何类型，包括函数类型</li>
<li>AnyObject 可以表示任何类类型的实例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var things = [Any]()</span><br><span class="line">things.append(0)</span><br><span class="line">things.append(0.0)</span><br><span class="line">things.append(&quot;hello&quot;)</span><br><span class="line"></span><br><span class="line">let optionalInt : Int? = 3</span><br><span class="line">things.append(optionalInt) //有警告</span><br><span class="line">things.append(optionalInt as Any) //没有警告</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong><br>Any类型可以表示所有类型的值，包括可选类型。Swift会在你用Any类型来表示一个可选类型的时候，会给你一个警告。如果你确实想使用Any类型来承载一个可选值，你可以使用as 操作符显示转换为Any</p>
<h4 id="嵌套类型"><a href="#嵌套类型" class="headerlink" title="嵌套类型"></a>嵌套类型</h4><p>枚举被常用于为特定的类或结果实现某些功能。类似的，枚举可以方便的定义工具类或结构体。Swift 允许定义嵌套类型，可以在支持的类型中定义嵌套的枚举、类和结构体</p>
<h5 id="嵌套类型实践"><a href="#嵌套类型实践" class="headerlink" title="嵌套类型实践"></a>嵌套类型实践</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">struct BlackjackCard &#123;</span><br><span class="line">	//嵌套的 Suit 枚举</span><br><span class="line">	enum Suit: Character &#123;</span><br><span class="line">		case spades = &quot;♠&quot;, hearts = &quot;♡&quot;, diamonds = &quot;♢&quot;, clubs = &quot;♣&quot;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//嵌套的Rank类型</span><br><span class="line">	enum Rank: Int &#123;</span><br><span class="line">		case two = 2, three, four, five, six, seven, eight, nine, ten </span><br><span class="line">		case jack , queen, king, ace</span><br><span class="line">		</span><br><span class="line">		struct Values &#123;</span><br><span class="line">			let first: Int, second: Int?</span><br><span class="line">		&#125;</span><br><span class="line">		var values: Values &#123;</span><br><span class="line">			switch self &#123;</span><br><span class="line">				case  .ace:</span><br><span class="line">					return Values(first: 1 ,second: 11)</span><br><span class="line">				case: .jack, .queen, .king</span><br><span class="line">					return Values(first: 10, second: nil)</span><br><span class="line">				default:</span><br><span class="line">					return Values(first: self.rawValue, second: nil)</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	let rank: Rank, suit: Suit</span><br><span class="line">	var description: String &#123;</span><br><span class="line">		var output = &quot;suit is \(suit.rawValue),&quot;</span><br><span class="line">		output += &quot;values is \(rank.values.first)&quot;</span><br><span class="line">		if let second = rank.values.second &#123;</span><br><span class="line">			output += &quot;or\(second)&quot;</span><br><span class="line">		&#125;</span><br><span class="line">		return output</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let theAceOfSpades = BlackjackCard(rank: .ace, suit:.spades);</span><br><span class="line">print(&quot;\(theAceOfSpades.description)&quot;)</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/25/option/" data-id="cjvlqkh6i0014uib8xrsfivqy" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Swift/">Swift</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-init" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/24/init/" class="article-date">
  <time datetime="2019-04-24T13:30:46.989Z" itemprop="datePublished">2019-04-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/24/init/">构造过程与析构过程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="构造过程"><a href="#构造过程" class="headerlink" title="构造过程"></a>构造过程</h3><p>构造过程是使用类、结构体、枚举类型的实例之前的准备过程。在新实例可用前必须执行这个过程，具体操作包括设置实例中每个存储属性的初始值和执行它必须设置或初始化的工作。</p>
<h4 id="存储属性的初始赋值"><a href="#存储属性的初始赋值" class="headerlink" title="存储属性的初始赋值"></a>存储属性的初始赋值</h4><p>类和结构体在在创建实例时，必须为所有存储属性设置合适的初始值。存储属性的值不能处于一个位置的状态。你可以在构造器中为存储属性赋初始值，也可以再定义属性是设置其默认值。</p>
<p><strong>注意</strong><br><em>当你为存储属性设置默认值或者在构造器中为其赋值时，它们的值是被直接设置的，不会触发任何属性观察器</em></p>
<h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><p>构造器在创建某个特定类型的新实例时被调用。以关键字<code>init</code>命名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">init()&#123;</span><br><span class="line">	// 在此执行构造过程</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="默认属性值"><a href="#默认属性值" class="headerlink" title="默认属性值"></a>默认属性值</h5><p>你可以在构造器中为存储属性设置初始值，也可以在属性声明时设置器默认值。提倡后者</p>
<h5 id="构造参数"><a href="#构造参数" class="headerlink" title="构造参数"></a>构造参数</h5><p>构造参数的语法跟函数和方法的参数相同</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct Celsius &#123;</span><br><span class="line">	var temperatureInCelsius : Double</span><br><span class="line">	init(fromFahrenheit fahrenheit: Double)&#123;</span><br><span class="line">		temperatureInCelsius = (fahrenheit - 32.0) / 1.8</span><br><span class="line">	&#125;</span><br><span class="line">	init(fromKelvin kelvin: Double)&#123;</span><br><span class="line">		temperatureInCelsius = kelvin - 273.15</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">let boilingPointOfWater = Clesius(fromFahrenheit: 200)</span><br><span class="line">let freezingPointOfWater = Clesius(fromKelvin: 273)</span><br></pre></td></tr></table></figure>
<h5 id="参数名和参数标签"><a href="#参数名和参数标签" class="headerlink" title="参数名和参数标签"></a>参数名和参数标签</h5><p>跟函数和方法参数相同，构造参数也拥有一个构造器内部使用的参数和一个在调用构造器时使用的参数标签。</p>
<p>如果定义构造器没有提供参数标签，Swift会为构造的每一个参数自动生成一个参数标签。</p>
<h5 id="不带参数标签的构造器"><a href="#不带参数标签的构造器" class="headerlink" title="不带参数标签的构造器"></a>不带参数标签的构造器</h5><p>如果你不希望构造器的某个参数提供参数标签，你可以使用’ _ ‘显示的来描述他的外部名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct Color &#123;</span><br><span class="line">	let red, green, blue: Double</span><br><span class="line">	init(red: Double, green: Double, blue: Double)&#123;</span><br><span class="line">		self.red = red</span><br><span class="line">		self.green = green</span><br><span class="line">		self.blue = blue</span><br><span class="line">	&#125;</span><br><span class="line">	init(_ white: Double)&#123;</span><br><span class="line">		red = white</span><br><span class="line">		green = white</span><br><span class="line">		blue = white</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">let magenta = Color(red: 1.0, green: 1.0 blue: 1.0)</span><br><span class="line">let white = Color(2.0)</span><br></pre></td></tr></table></figure>
<h5 id="可选属性类型"><a href="#可选属性类型" class="headerlink" title="可选属性类型"></a>可选属性类型</h5><p>如果你定制的类包含一个逻辑上允许取值为空的存储属性。</p>
<h5 id="构造过程中常量属性的赋值"><a href="#构造过程中常量属性的赋值" class="headerlink" title="构造过程中常量属性的赋值"></a>构造过程中常量属性的赋值</h5><p>在构造过程中任意时间点给一个常量属性指定一个值，只要在构造过程结束时是一个确定的值。一旦常量属性被赋值，它将永远不可更改。</p>
<p><strong>注意</strong><br><em>对于类实例来说，它的常量属性只能在定义他的类的构造过程中修改，不能在子类修改</em></p>
<h4 id="默认构造器"><a href="#默认构造器" class="headerlink" title="默认构造器"></a>默认构造器</h4><p>如果结构体或类的所有属性都有默认值，同时没有自定义的构造器，那么Swift会给这些结构体或类提供一个默认构造器。这个默认构造器将简单地创建一个所有属性值都设置为默认值的实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class ShoppingListItem &#123;</span><br><span class="line">	var name: String ?</span><br><span class="line">	var quantity = 1</span><br><span class="line">	var purchased = false</span><br><span class="line">&#125;</span><br><span class="line">var itme = ShopingListItem()</span><br></pre></td></tr></table></figure></p>
<h4 id="结构体的逐一成员构造器"><a href="#结构体的逐一成员构造器" class="headerlink" title="结构体的逐一成员构造器"></a>结构体的逐一成员构造器</h4><p>除了上面提到的默认构造器，如果结构体没有提供自定义的构造器，它们将自动获得一个逐一成员构造器，即使结构体的存储型属性没有默认值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct Size &#123;</span><br><span class="line">	var width = 0.0 , height = 0.0</span><br><span class="line">&#125;</span><br><span class="line">let size = Size(width: 5.0, height: 2.0)</span><br></pre></td></tr></table></figure>
<h4 id="值类型的构造器代理"><a href="#值类型的构造器代理" class="headerlink" title="值类型的构造器代理"></a>值类型的构造器代理</h4><p>构造器可以通过调用其他构造器来完成实例的部分构造过程，这一过程称为构造器代理，它能避免多个构造器间的代码重复。</p>
<p>对于值类型，你可以使用<code>self.init</code>在自定义的构造器中引用相同类型中的其它构造器。并且你只能在构造器内部调用 <code>self.init</code></p>
<p><strong>注意</strong></p>
<ul>
<li><p>如果你为某个值类型定义了自定义构造器，你将无法访问到默认构造器（如果是结构体，还将无法访问成员逐一构造器）。</p>
</li>
<li><p>假如你己自定希望默认构造器、逐一成员构造器以及你自义构造器都能用来创建实例，可以将自定义的构造器写到扩展中，而不是写在值类型的原始定义中</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">struct Size &#123;</span><br><span class="line">	var width = 0.0, height = 0.0</span><br><span class="line">&#125;</span><br><span class="line">struct Point&#123;</span><br><span class="line">	var x = 0.0, y = 0.0</span><br><span class="line">&#125;</span><br><span class="line">struct Rect &#123;</span><br><span class="line">	var origin = Point()</span><br><span class="line">	var size = Size()</span><br><span class="line">	init()&#123;&#125;</span><br><span class="line">	init(origin: Point, size: Size)&#123;</span><br><span class="line">		self.origin = origin</span><br><span class="line">		self.size = size</span><br><span class="line">	&#125;</span><br><span class="line">	init(center: Point, size: Size)&#123;</span><br><span class="line">		let originX = center.x - size.width / 2</span><br><span class="line">		let originY = center.y - size.height / 2</span><br><span class="line">		self.init(origin: Point(x: originX, y: originY, size: size))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类的继承和构造过程"><a href="#类的继承和构造过程" class="headerlink" title="类的继承和构造过程"></a>类的继承和构造过程</h4><p>类里面的所有存储属性（包括所有继承自父类的属性）都必须在构造过程中设置初始值。Swift为类提供了指定构造器和便利构造器来确保实例中所有存储型属性都能获得初始值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//指定构造器语法 跟值类型的简单构造器一样</span><br><span class="line">init(parameters)&#123;</span><br><span class="line">	statements</span><br><span class="line">&#125;</span><br><span class="line">//便利构造器语法</span><br><span class="line">convenience init(parameters)&#123;</span><br><span class="line">	statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="类的构造器的代理规则"><a href="#类的构造器的代理规则" class="headerlink" title="类的构造器的代理规则"></a>类的构造器的代理规则</h5><ol>
<li>指定构造器必须调用其直接父类的指定构造器</li>
<li>便利构造器必须调用同类中定义的其他构造器</li>
<li>便利构造器最后必须调用指定构造器</li>
</ol>
<h5 id="两断式构造过程"><a href="#两断式构造过程" class="headerlink" title="两断式构造过程"></a>两断式构造过程</h5><p>Swift中类的构造过程包含两个阶段。第一阶段，类中的每一个存储型属性赋一个初始值。当每个存储型属性的初始值赋值后，第二阶段开始，它给每个类一次机会，在新实例准备使用之前进一步定制它们的存储型属性</p>
<h5 id="构造器的继承和重写"><a href="#构造器的继承和重写" class="headerlink" title="构造器的继承和重写"></a>构造器的继承和重写</h5><p>与OC中的子类不同，Swift中的子类默认情况不会继承父类构造器。</p>
<p><strong>注意</strong><br><em>父类的构造器会在安全和适当的情况下被继承。</em></p>
<p>假如你希望自定义子类能提供一个或多个跟父类相同的构造器，你可以在子类中提供这些构造器的自定义实现。</p>
<p>当你在编写一个和父类中指定构造器相匹配的子类构造器时，你实际上是重写父类的这个指定构造器。因此，你必须在子类构造时带上<code>override</code>修饰符</p>
<p>相反，如果你编写了一个和父类便利构造器相匹配的子类构造器，由于子类不能直接调用父类的便利构造器。因此，你的子类并未对一个父类构造器提供重写。不需要加 <code>override</code>修饰符</p>
<p><strong>注意</strong><br><em>子类可以在初始化时修改继承来的变量属性，但不能修改继承来的常量属性</em></p>
<h5 id="构造器的自动继承"><a href="#构造器的自动继承" class="headerlink" title="构造器的自动继承"></a>构造器的自动继承</h5><p>如上所述，子类在默认情况下不会继承父类的构造器。但是如果满足特定条件，父类构造器是可以被自动继承的。</p>
<p>假设你为子类中引入的所有新属性都提供了默认值。以下2个规则适用：</p>
<ol>
<li>如果子类没有定义任何指定构造器，它将自动继承父类中的所有指定构造器</li>
<li>如果子类提供了所有父类指定构造器的实现–无论是通过规则1继承过来的还是提供了自定义实现。它将自动继承所有便利构造器</li>
</ol>
<p><strong>注意</strong>对于规则2，子类可以将父类的指定构造器实现为便利构造器</p>
<h4 id="指定构造器和便利构造器实践"><a href="#指定构造器和便利构造器实践" class="headerlink" title="指定构造器和便利构造器实践"></a>指定构造器和便利构造器实践</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class Food &#123;</span><br><span class="line">	var name : String</span><br><span class="line">	init(name: String)&#123;</span><br><span class="line">		self.name = name</span><br><span class="line">	&#125;</span><br><span class="line">	convenience init()&#123;</span><br><span class="line">		//便利构造器一定要调用指定构造器</span><br><span class="line">		self.init(name: &quot;[Unnamed]&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">let nameMeat = Food(name: &quot;Bacon&quot;)</span><br><span class="line">let mysteryMeat = Food()</span><br><span class="line"></span><br><span class="line">class RecipeIngredient: Food &#123;</span><br><span class="line">	var quantity: Int</span><br><span class="line">	init(name: String, quantity: Int)&#123;</span><br><span class="line">		self. quantity = quantity</span><br><span class="line">		super.init(name: name)</span><br><span class="line">	&#125;</span><br><span class="line">	//这里重写了父类的指定构造器 要用 override 修饰</span><br><span class="line">	//实现了父类所有指定构造器，将自动继承父类的便利构造器</span><br><span class="line">	override convenience init(name: Stirng)&#123;</span><br><span class="line">		self.init(name: name, quantity: 1)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let oneMysteryItem = RecipeIngredient()</span><br><span class="line">let oneBacon = RecipeIngredient(name: &quot;Bacon&quot;)</span><br><span class="line">let sixEggs = RecipeIngredient(name: &quot;Eggs&quot;, quantity: 6)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ShopingListItem: RecipeIngredient &#123;</span><br><span class="line">	var purchased = false</span><br><span class="line">	var description: String &#123;</span><br><span class="line">		var output = &quot;\(quantity) * \(name)&quot;</span><br><span class="line">		output += purchased ? &quot;1&quot; : &quot;2&quot;</span><br><span class="line">		return output</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//由于自己引入的属性提供了默认值，并且自己也没有指定构造器，因此ShopingListItem将自动继承父类所有指定构造器和便利构造器</span><br><span class="line"></span><br><span class="line">var breakfastList = [ShopingListItem(),ShoppingListItem(name: &quot;Bacon&quot;),ShoppingListItem(name: &quot;Eggs&quot;, quantity: 6)]</span><br><span class="line">breakfastList[0].name = &quot;Orange juice&quot;</span><br><span class="line">breakfastList[0].purchased = ture</span><br><span class="line">for item in breakfastList &#123;</span><br><span class="line">	print(item.description)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="可失败构造器"><a href="#可失败构造器" class="headerlink" title="可失败构造器"></a>可失败构造器</h4><p>你可以在一个类、结构体或者枚举类型定义中，添加一个或多个可失败构造器。其语法为在 <code>init</code>关键字后面添加问号（<code>init?</code>）</p>
<p><strong>注意：</strong>可失败构造器的参数名和参数类型，不能与其它非可失败构造器的参数名和参数类型相同</p>
<p>可失败构造器创建一个类型为自身类型的可选类型对象。通过 <code>return nil</code>语句来表明可失败构造器在何种情况下应该失败</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct Animal &#123;</span><br><span class="line">	let species: String </span><br><span class="line">	init?(species: String)&#123;</span><br><span class="line">		if species.isEmpty &#123;</span><br><span class="line">			return nil</span><br><span class="line">		&#125;</span><br><span class="line">		self.species = species</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="枚举类型的可失败构造器"><a href="#枚举类型的可失败构造器" class="headerlink" title="枚举类型的可失败构造器"></a>枚举类型的可失败构造器</h5><p>你可以通过一个或多个参数的可失败构造器来获取枚举类型中特定的枚举成员。如果提供的参数无法匹配任何枚举成员，则构造失败</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">enum TemperatureUnit &#123;</span><br><span class="line">	case Kelvin, Celsius, Fahrenheit</span><br><span class="line">	init?(symbol: Character)&#123;</span><br><span class="line">		switch symbol&#123;</span><br><span class="line">		case &quot;K&quot;:</span><br><span class="line">			self = .Kelvin</span><br><span class="line">		case &quot;C&quot;:</span><br><span class="line">			self = .Celsius</span><br><span class="line">		case &quot;F&quot;:</span><br><span class="line">			self = .Fahrenheit</span><br><span class="line">		default:</span><br><span class="line">			return nil</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="带原始值的枚举类型的可失败构造器"><a href="#带原始值的枚举类型的可失败构造器" class="headerlink" title="带原始值的枚举类型的可失败构造器"></a>带原始值的枚举类型的可失败构造器</h5><p>带原始值的枚举类型会自动带一个可失败构造器 <code>init?(rawValue:)</code>,该失败构造器有一个名为<code>rawValue</code>的参数，其类型和枚举类型的原始值类型一致。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum TemperatureUnit: Character&#123;</span><br><span class="line">	case kevlin = &quot;K&quot;, Celsius = &quot;C&quot;, Fahrenheit = &quot;F&quot;</span><br><span class="line">&#125;</span><br><span class="line">let fahrenheitUnit = TemperatureUnit(rawValue: &quot;F&quot;)</span><br></pre></td></tr></table></figure>
<h5 id="构造失败的传递"><a href="#构造失败的传递" class="headerlink" title="构造失败的传递"></a>构造失败的传递</h5><p>类、结构体和枚举的可失败构造器可以横向代理到同类型中其他可失败构造器。类似的，子类的可失败构造器也能向上代理到父类的可失败构造器。</p>
<p>无论是向上代理还是横向代理，如果你代理到其他可失败构造器触发构造失败，整个构造器就立即终止</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Product &#123;</span><br><span class="line">	let name: String </span><br><span class="line">	init?(name: String)&#123;</span><br><span class="line">		if name.isEmpty &#123; return nil &#125;</span><br><span class="line">		self.name = name</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">calss CartItem: Product &#123;</span><br><span class="line">	let quantity: Int</span><br><span class="line">	init?(name: String, quantity: Int)&#123;</span><br><span class="line">		if auantity &lt; 1 &#123; return nil &#125;</span><br><span class="line">		self.quantity = quantity</span><br><span class="line">		super.init(name: name)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="重写一个可失败构造器"><a href="#重写一个可失败构造器" class="headerlink" title="重写一个可失败构造器"></a>重写一个可失败构造器</h5><p>你可以在子类中重写父类的可失败构造器。或者你也可以用子类的非可失败构造器重写一个父类的可失败构造器。</p>
<p>当你用子类的非可失败构造器重写父类的可失败构造器时，向上代理到父类的可失败的唯一方式是对父类的可失败构造的反回值强行解包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Document &#123;</span><br><span class="line">	var name : String ?</span><br><span class="line">	init &#123;&#125;</span><br><span class="line">	init?(name: String)&#123;</span><br><span class="line">		self.name = name</span><br><span class="line">		if name.isEmpty &#123;</span><br><span class="line">			return nil</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class AutomaticallyNameDocument: Document &#123;</span><br><span class="line">	override init()&#123;</span><br><span class="line">		super.init()</span><br><span class="line">		self.name = &quot;[Untitled]&quot;</span><br><span class="line">	&#125;</span><br><span class="line">	override init(name: String)&#123;</span><br><span class="line">		super.init()</span><br><span class="line">		if name.isEmpty &#123;</span><br><span class="line">			self.name = &quot;[Untitled]&quot;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			self.name = name</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class UntitledDocument : Document &#123;</span><br><span class="line">	override init() &#123;</span><br><span class="line">		//强行解包</span><br><span class="line">		super.init(name: &quot;[Untitled]&quot;)!</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="init-可失败构造器"><a href="#init-可失败构造器" class="headerlink" title="init!可失败构造器"></a>init!可失败构造器</h5><p><code>init!</code>将会建立一个对应类型的隐式解包可选类型对象</p>
<h4 id="必要构造器"><a href="#必要构造器" class="headerlink" title="必要构造器"></a>必要构造器</h4><p>在类的构造器前面添加 <code>required</code> 修饰符表明所有的该子类都必须实现该构造器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class SomeClass &#123;</span><br><span class="line">	required init()&#123;</span><br><span class="line">		//构造器的实现代码</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类重写父类必要构造器是，必须在子类构造器前添加<code>required</code>修饰符，表明该构造器要求也应用于继承链后面的子类。在重写父类中必要的指定构造器时，不需要添加 <code>override</code> 修饰符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class SomeSubclass : SomeClass &#123;</span><br><span class="line">	required init ()	&#123;</span><br><span class="line">		// 构造器的实现</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="通过闭包或函数设置属性的默认值"><a href="#通过闭包或函数设置属性的默认值" class="headerlink" title="通过闭包或函数设置属性的默认值"></a>通过闭包或函数设置属性的默认值</h4><p>如果存储属性的默认值需要一些定制或设置，你可以使用<strong>闭包</strong>或<strong>全局函数</strong>为其提供定制的默认值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class SomeClass &#123;</span><br><span class="line">	let someProperty: SomeType = &#123;</span><br><span class="line">		//someValue 必须和SomeType类型相同</span><br><span class="line">		return someValue</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意闭包结尾后面接了一对空的小括号。这里用来告诉Swift立即执行此闭包。如果你忽略了这对括号，相当于将闭包本身赋值给了属性，而不是将闭包的返回值赋值给属性。</p>
<p><strong>注意：</strong>如果你使用闭包来初始化属性，请记住在闭包执行时，实例的其他部分还没初始化。这意味着你不能在闭包里访问其他属性，即使这些属性有默认值。同样，你也不能使用隐式的<code>self</code>属性，或者调用其他任何实例方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct Chessboard &#123;</span><br><span class="line">	let boardColors: [Bool] = &#123;</span><br><span class="line">		var temporaryBoard = [Bool]()</span><br><span class="line">		var isBlack = false </span><br><span class="line">		for i in 1...8 &#123;</span><br><span class="line">			for j in 1..8&#123;</span><br><span class="line">				temporaryBoard.append(isBlack)</span><br><span class="line">				isBlack = !isBlack</span><br><span class="line">			&#125;</span><br><span class="line">			isBlack = !isBlack</span><br><span class="line">		&#125;</span><br><span class="line">		return  temporaryBoard</span><br><span class="line">	&#125;()</span><br><span class="line">	func squarIsBlackAt(raw: Int, column: Int) -&gt;Bool &#123;</span><br><span class="line">		return boardColors[(raw * 8) + column]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="析构过程"><a href="#析构过程" class="headerlink" title="析构过程"></a>析构过程</h3><p>析构器只适用于类类型，当一个类的实例被释放之前，析构器会立即调用。析构器用关键<code>deinit</code>来标识</p>
<h4 id="析构过程原理"><a href="#析构过程原理" class="headerlink" title="析构过程原理"></a>析构过程原理</h4><p>Swift 会自动释放不再需要的实例以释放资源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deinit &#123;</span><br><span class="line">	//执行析构过程</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>析构器在实例释放前会被自动调用。你不能主动调用析构器。</p>
<p>直到实例析构器被调用后，实例才会被释放，所以析构器可以访问实例的所有属性。</p>
<h4 id="析构器实践"><a href="#析构器实践" class="headerlink" title="析构器实践"></a>析构器实践</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Bank &#123;</span><br><span class="line">	static var coinsInBank = 10000;</span><br><span class="line">	static func distribute(coins numberOfCoinsRequested: Int) -&gt; Int &#123;</span><br><span class="line">		let numberOfCoinsToVend = min(numberOfCoinsRequested, coinsInBank)</span><br><span class="line">		coinsInbank -= numberOfCoinsToVend</span><br><span class="line">		return numberOfCoinsToVend</span><br><span class="line">	&#125;</span><br><span class="line">	static func recive(coins: Int)&#123;</span><br><span class="line">		coinsInBank += coins</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Player : Int &#123;</span><br><span class="line">	var coinsInpurse: Int </span><br><span class="line">	init(coins: Int)&#123;</span><br><span class="line">		coinsInpurse = Bank.distribute(coins: coins)</span><br><span class="line">	&#125;</span><br><span class="line">	func win(cons: Int)&#123;</span><br><span class="line">		coinsInpurse += Bank.distribute(coins: coins)</span><br><span class="line">	&#125;</span><br><span class="line">	deinit&#123;</span><br><span class="line">		Bank.recive(coins: coinsInpurse)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/24/init/" data-id="cjvlqkh6d000quib8vjy1shq4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Swift/">Swift</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-method_subscripte" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/23/method_subscripte/" class="article-date">
  <time datetime="2019-04-23T09:21:23.006Z" itemprop="datePublished">2019-04-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/23/method_subscripte/">方法 下标 继承</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>方法是与某些特定类型相关联的函数。</p>
<h4 id="实例方法（Instance-Methods）"><a href="#实例方法（Instance-Methods）" class="headerlink" title="实例方法（Instance Methods）"></a>实例方法（Instance Methods）</h4><p>实例方法是属于某个特定类、结构体或枚举类型实例的方法。</p>
<h5 id="self属性"><a href="#self属性" class="headerlink" title="self属性"></a>self属性</h5><p>类型的每一个属性都有一个隐含属性叫做<code>self</code>，self完全等同于该实例本身。</p>
<h5 id="在实例方法中修改值类型"><a href="#在实例方法中修改值类型" class="headerlink" title="在实例方法中修改值类型"></a>在实例方法中修改值类型</h5><p>结构体和枚举是值类型。默认情况下，值类型的属性不能在它的实例方法中被修改。</p>
<p>但是，如果你确实需要在某个特定的方法中修改结构体或者枚举属性，你可以为这个方法选择可变（<code>mutating</code>）行为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Struct Point &#123;</span><br><span class="line">	var x = 0.0 y = 0.0</span><br><span class="line">	mutating func moveByX(_ delateX: Double,_ delateY: Double)&#123;</span><br><span class="line">		x += delateX</span><br><span class="line">		y += delateY</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="在可变方法中给self赋值"><a href="#在可变方法中给self赋值" class="headerlink" title="在可变方法中给self赋值"></a>在可变方法中给self赋值</h5><p>可变方法能够赋给隐含属性self一个全新的实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Point &#123;</span><br><span class="line">	var x = 0.0 , y = 0.0</span><br><span class="line">	mutating func moveByX(x delataX: Double, y delataY: Double)&#123;</span><br><span class="line">		self = Point(x: x + delateX, y: y + delataY)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类型方法"><a href="#类型方法" class="headerlink" title="类型方法"></a>类型方法</h4><p>定义类型本身调用的方法叫类型方法。<code>static</code>关键字。类还可以用关键字class允许子类重写父类的方法实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class SomeClass &#123;</span><br><span class="line">	class func someTypeMethod() &#123;</span><br><span class="line">		// 在这里实现类型方法</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">SomeClass.someTypeMethod()</span><br></pre></td></tr></table></figure>
<h3 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h3><p>下标可以定义在类、结构体和枚举中，是访问集合、列表或有序列表中元素的快捷方式。someArray[index] somDictionary[key]</p>
<p>一个类型可以定义多个下标，通过不同索引类型进行重载。下标不限于一维，你可以定义多个入参的下标满足自定义类型的需求。</p>
<h4 id="下标语法"><a href="#下标语法" class="headerlink" title="下标语法"></a>下标语法</h4><p>下标定义使用 <code>subscript</code> 关键字。下标可以设定读写或只读。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">subscript(index: Int) -&gt; Int&#123;</span><br><span class="line">	get&#123;</span><br><span class="line">		//返回一个适当的Int 类型的值</span><br><span class="line">	&#125;</span><br><span class="line">	set(newValue)&#123;</span><br><span class="line">		//执行适当的赋值操作</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//newValue 的类型和返回类型相同</span><br></pre></td></tr></table></figure>
<p>如果只读计算型属性，可以省略只读下标的 get 关键字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">subscript(index: int) -&gt; Int&#123;</span><br><span class="line">	//返回一个适当的Int 类型的值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct TimesTable &#123;</span><br><span class="line">	let multiplier: Int</span><br><span class="line">	subscript(index: Int) -&gt; Int&#123;</span><br><span class="line">		return multipliter * index</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="下标用法"><a href="#下标用法" class="headerlink" title="下标用法"></a>下标用法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var numberOfLegs = [&quot;spider&quot;: 8, &quot;ant&quot;: 6, &quot;cat&quot;: 4]</span><br><span class="line">numberOfLegs[&quot;bird&quot;] = 2</span><br></pre></td></tr></table></figure>
<p>Swift 中Dictionary类型的下标接受并返回可选类型的值。Dictionary之所如此实现，是因为不是每个键都有个对应的值。同时这也提供了一种通过键删除对应值的方式，只需要将键对应的值赋值为nil即可</p>
<h4 id="下标选项"><a href="#下标选项" class="headerlink" title="下标选项"></a>下标选项</h4><p>下标可以接受任意数量的入参，并且这些入参可以是任意类型。下标的返回值也可以是任意类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var list = [Double]()</span><br><span class="line">subscript(row: Int, column: Int) -&gt; Double &#123;</span><br><span class="line">	get&#123;</span><br><span class="line">		return list[row * column]</span><br><span class="line">	&#125;</span><br><span class="line">	set&#123;</span><br><span class="line">		list[row *column] = newValue</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>一个类可以继承另一个类的方法，属性和其他特性。继承是区分类与其它类型的基本特征。</p>
<p>可以为类中继承来的属性添加属性观察器，无论它原本被定义为存储属性还是计算属性</p>
<h4 id="定义一个基类"><a href="#定义一个基类" class="headerlink" title="定义一个基类"></a>定义一个基类</h4><p>不继承其它类的类，称之为基类</p>
<h4 id="子类生成"><a href="#子类生成" class="headerlink" title="子类生成"></a>子类生成</h4><p>子类生成指的是在一个已有类的基础上创建一个新的类。子类继承父类的特性，并且可以进一步完善。</p>
<h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><p>子类可以为继承来的实例方法，类方法，实例属性，或下标提供自己定制的实现。这种行为叫重写。</p>
<p>如果要重新某个特性，你需要在定义的前面加上<code>override</code>关键字。</p>
<h4 id="访问父类的方法，属性及下标"><a href="#访问父类的方法，属性及下标" class="headerlink" title="访问父类的方法，属性及下标"></a>访问父类的方法，属性及下标</h4><ul>
<li>在方法 someMethod() 的重写实现中，可以通过 super.someMethod() 来调用父类版本的someMethod()方法</li>
<li>在属性 someProperty() 的getter 或 setter实现中，可以通过 super.someProperty 来访问父类的属性</li>
<li>在下标的重写实现中，可以通过 super[someindex]来访问父类版本中的相同下标</li>
</ul>
<h5 id="重写方法"><a href="#重写方法" class="headerlink" title="重写方法"></a>重写方法</h5><h5 id="重写属性"><a href="#重写属性" class="headerlink" title="重写属性"></a>重写属性</h5><p>你可以提供定制的getter或setter来重写任意继承来的属性，无论继承来的属性是存储型属性还是计算型属性。</p>
<p><strong>注意</strong>：</p>
<ul>
<li><p>你可以将一个继承来的只读属性重写为一个读写属性，只需要在重新版本的属性里提供getter和setter即可。但是，你不可以将一个继承来的读写属性重写为一个只读属性</p>
</li>
<li><p>如果你的重写属性中提供了setter，那么你也一定要提供getter。如果你不想在重写版本中的getter里修改继承来的属性值，你可以通过super.someProperty来返回继承来的值。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Car : Vehicle &#123;</span><br><span class="line">	var gear = 1</span><br><span class="line">	override func someOverrideFunc()&#123;</span><br><span class="line">		//</span><br><span class="line">	&#125;</span><br><span class="line">	override var desciption: String &#123;</span><br><span class="line">		return super.description + &quot;in gear\(gear)&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="重写属性观察器"><a href="#重写属性观察器" class="headerlink" title="重写属性观察器"></a>重写属性观察器</h5><p>可以通过重写属性为一个继承来的属性添加属性观察器</p>
<p><em>你不可以为继承来的常量存储型属性或继承来的只读计算型属性添加属性观察器。这些属性的值是不可以被设置的，所以为他们提供willSet或didSet实现是不恰当的。</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class AutomaticCar :Car &#123;</span><br><span class="line">	 override var currentSpeed: Double&#123;</span><br><span class="line">	 	didSet &#123;</span><br><span class="line">	 		gear = Int(currentSpeed / 10.0) + 1</span><br><span class="line">	 	&#125;</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="防止重写"><a href="#防止重写" class="headerlink" title="防止重写"></a>防止重写</h4><p>你可以通过方法、属性、下标前面添加<code>final</code>关键字来防止他们被重写：<code>final var</code> 、<code>final func</code>、<code>final class func</code>、<code>final subscript</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/23/method_subscripte/" data-id="cjvlqkh6h0011uib85vsb66fz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Swift/">Swift</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Swift-ClassAndStruct" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/23/Swift-ClassAndStruct/" class="article-date">
  <time datetime="2019-04-23T08:01:27.777Z" itemprop="datePublished">2019-04-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/23/Swift-ClassAndStruct/">类和结构体  属性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="类和结构体"><a href="#类和结构体" class="headerlink" title="类和结构体"></a>类和结构体</h3><h4 id="类和结构体的对比"><a href="#类和结构体的对比" class="headerlink" title="类和结构体的对比"></a>类和结构体的对比</h4><p>共同点：</p>
<ul>
<li>定义属性用于存储值</li>
<li>定义方法用于提供功能</li>
<li>定义下标操作通过下标语法可以访问它们的值</li>
<li>定义构造器用于生成初始化值</li>
<li>通过扩展增加默认实现的功能</li>
<li>遵循协议提供某种标准功能</li>
</ul>
<p>与结构体相比，类还有如下附加功能：</p>
<ul>
<li>继承：允许一个类继承另一个类的特征</li>
<li>类型转换：允许在运行时检查和解释一个类实例的的类型</li>
<li>析构器：运行一个类实例释放任何其所被分配的资源</li>
<li>引用计数：允许对一个类多次引用</li>
</ul>
<h4 id="定义语法"><a href="#定义语法" class="headerlink" title="定义语法"></a>定义语法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class SomeClass&#123;</span><br><span class="line">	//在这里定义类</span><br><span class="line">&#125;</span><br><span class="line">struct SomeStructure&#123;</span><br><span class="line">	//</span><br><span class="line">&#125;</span><br><span class="line">注意命名风格</span><br></pre></td></tr></table></figure>
<h4 id="类和结构体实例"><a href="#类和结构体实例" class="headerlink" title="类和结构体实例"></a>类和结构体实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Resolution&#123;</span><br><span class="line">	var width = 0</span><br><span class="line">	var height = 0</span><br><span class="line">&#125;</span><br><span class="line">let someResolution = Resolution()</span><br><span class="line">let someVideoMode = VideoMode()</span><br></pre></td></tr></table></figure>
<p>结构体和类都使用构造器来生成新的实例。构造器最简单的形式就是在后面跟随一对空括号。通过这种方式其属性均会被初始化默认值。</p>
<h4 id="属性访问"><a href="#属性访问" class="headerlink" title="属性访问"></a>属性访问</h4><p>通过点语法访问实例的属性。也可通过点语法为变量属性进行赋值</p>
<h4 id="结构体类型的成员逐一构造器"><a href="#结构体类型的成员逐一构造器" class="headerlink" title="结构体类型的成员逐一构造器"></a>结构体类型的成员逐一构造器</h4><p>所有的结构体都有一个<strong>自动生成</strong>的成员逐一构造器，用于初始化新构体实例中成员的属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let var = Resolution(width: 640, height: 4800)</span><br></pre></td></tr></table></figure></p>
<h4 id="结构体和枚举是值类型"><a href="#结构体和枚举是值类型" class="headerlink" title="结构体和枚举是值类型"></a>结构体和枚举是值类型</h4><p>值类型被赋予一个变量、常量或者被传递给一个函数的时候，其值会被拷贝。</p>
<h4 id="类是引用类型"><a href="#类是引用类型" class="headerlink" title="类是引用类型"></a>类是引用类型</h4><p>引用类型被赋予到一个变量、常量或者被传递到一个函数时，其值不会被拷贝。因此引用的是已存在的实例本身，不是其拷贝。</p>
<h4 id="恒等运算符"><a href="#恒等运算符" class="headerlink" title="恒等运算符"></a>恒等运算符</h4><p>因为类是引用类型，有可能多个常量和变量在幕后同时引用同一个类实例。运用以下2个运算符检测两个常量或者变量是否引用同一个实例</p>
<ul>
<li>等价于（===）</li>
<li>不等价于（!==）</li>
</ul>
<h4 id="类和结构体的选择"><a href="#类和结构体的选择" class="headerlink" title="类和结构体的选择"></a>类和结构体的选择</h4><p>当符合一条或者多条以下条件时，请考虑构建结构体</p>
<ul>
<li>该数据结构的主要目的是用来封装少量相关简单数据值</li>
<li>有理由预计该数据结构的实例在被赋值或传递时，封装的数据将会被拷贝而不是被引用</li>
<li>该数据结构不需要去继承另一个既有类型的属性或者行为</li>
</ul>
<p>注意：Swift中拷贝行为看起来总会发生，然而，Swift在幕后只用在决定必要时才执行实际拷贝。Swift管理所有的值拷贝以确保性能最优化，所以你没必要去回避赋值来保证性能最优化</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><h4 id="存储属性"><a href="#存储属性" class="headerlink" title="存储属性"></a>存储属性</h4><p>存储属性就是存储在特定类或结构体实例里的一个常量或变量。可以在定义存储属性的时候指定特定默认值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct FixedLengthRange &#123;</span><br><span class="line">	var firstValue: Int</span><br><span class="line">	let length: Int</span><br><span class="line">&#125;</span><br><span class="line">var rangeOfThreeItems = FixedLengthRange(firstValue: 0, length: 3)</span><br><span class="line">rangeOfThreeItems.firstValue = 6</span><br></pre></td></tr></table></figure>
<h5 id="常量结构体的存储属性"><a href="#常量结构体的存储属性" class="headerlink" title="常量结构体的存储属性"></a>常量结构体的存储属性</h5><p>如果创建了一个结构体的实例并将其赋值给一个常量，则无法修改该实例的任何属性，即使有属性被声明为变量也不行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let rangeOfFourItems = FixedLengthRange(firstValue: 0, length: 4)</span><br><span class="line">rangeOfFourItems.firtValue=6//这里会报错</span><br></pre></td></tr></table></figure>
<p>这种行为由于结构体属于值类型。当值类型的实例被声明为常量的时候，它的所有属性也就成了常量</p>
<h5 id="延迟存储属性"><a href="#延迟存储属性" class="headerlink" title="延迟存储属性"></a>延迟存储属性</h5><p>延迟存储属性是值当第一次调用的时候才会去计算其初始值的属性。在属性声明前使用<code>lazy</code>关键字。</p>
<p>必须将延迟存储属性声明成变量，因为属性的初始值可能在实例构造完成后才会得到。而常量属性在构造过程完成之前必须要有初始值，因此无法声明成延迟属性。</p>
<h4 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h4><p>除存储属性外，类、结构体、和枚举可以定义计算属性。计算属性不直接存储值，而是通过一个getter和一个可选的setter来间接获取和设置其他属性或变量的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">struct Point &#123;</span><br><span class="line">	var x = 0.0, y = 0.0</span><br><span class="line">&#125;</span><br><span class="line">struct Size &#123;</span><br><span class="line">	Var width = 0.0, height = 0.0</span><br><span class="line">&#125;</span><br><span class="line">struct Rect &#123;</span><br><span class="line">	var origin = Point()</span><br><span class="line">	var size = Size()</span><br><span class="line">	var center: Point&#123;</span><br><span class="line">		get &#123;</span><br><span class="line">			let centerX = orign.x + (size.width / 2)</span><br><span class="line">			let centerY = orign.y + (size.height / 2)</span><br><span class="line">			return Point(x: centerX, y: centerY)</span><br><span class="line">		&#125;</span><br><span class="line">		set(newCenter)&#123;</span><br><span class="line">			orign.x = newCenter.x - (size.width / 2)</span><br><span class="line">			orign.y = newCenter.y - (size.height / 2)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">var square = Rect(origin: Point(x: 0.0, y0.0), size: Size(width: 10.0, height: 10.0))</span><br><span class="line">let initCenter = square.center</span><br><span class="line">square.center = Point(x: 15.0, y: 15.0)</span><br></pre></td></tr></table></figure>
<h5 id="简化Setter声明"><a href="#简化Setter声明" class="headerlink" title="简化Setter声明"></a>简化Setter声明</h5><p>如果计算属性的setter没有定义表示新值的参数名，则可以使用默认名称 newValue。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct AlternativeRect&#123;</span><br><span class="line">	var orign = Point()</span><br><span class="line">	var size = Size()</span><br><span class="line">	var center: Point &#123;</span><br><span class="line">		get &#123;</span><br><span class="line">			let centerX = origin.x + (size.width / 2)</span><br><span class="line">			let centerY = origin.y + (size.height / 2)</span><br><span class="line">			return Point(x: centerX, y: centerY)</span><br><span class="line">		&#125;</span><br><span class="line">		set &#123;</span><br><span class="line">			orign.x = newValue.x - (size.width / 2)</span><br><span class="line">			orign.y = newValue.y - (size.height / 2)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="只读计算属性"><a href="#只读计算属性" class="headerlink" title="只读计算属性"></a>只读计算属性</h5><p>只有geter 没有setter 的计算属性就是只读计算属性。只读计算属性总是返回一个值。<br>只读计算属性的声明可以去掉 <code>get</code>关键字和大括号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Clubid&#123;</span><br><span class="line">	var width = 0.0, height = 0.0, depth = 0.0</span><br><span class="line">	var volume: Double &#123;</span><br><span class="line">		return  width * height * depth</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="属性观察器"><a href="#属性观察器" class="headerlink" title="属性观察器"></a>属性观察器</h4><p>属性观察器监控和响应属性值的变化，每次属性设置的时候都会调用属性观察器。</p>
<p><code>willSet</code>在新的值被设置之前调用</p>
<p><code>didSet</code>在新的被设置之后立即调用</p>
<p><em>注意：<br>父类的属性在子类的构造器中被赋值时，它在父类中的willSet 和didSet 观察器会被调用，随后才会调用子类的观察器</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class SetpCounter &#123;</span><br><span class="line">	var totalSteps: Int = 0 &#123;</span><br><span class="line">		willSet(newTotalSteps)&#123;</span><br><span class="line">			print(&quot;About to set totalSteps to \(newTotalSteps)&quot;)</span><br><span class="line">		&#125;</span><br><span class="line">		didSet&#123;</span><br><span class="line">			if</span><br><span class="line">			totalSteps &gt; oldValue &#123;</span><br><span class="line">				print(&quot;Added \(totalSteps - oldValue) steps&quot;)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h4><p>计算属性和属性观察器所描述的功能也可以用于<code>全局变量</code>和<code>局部变量</code></p>
<p>全局变量和局部变量都属于存储型变量，跟存储属性类似。另外全局和局部范围都可以定义计算型变量和为存储型变量定义观察器。计算型变量跟计算属性一样，返回一个计算结果而不是存储值，声明格式也一样</p>
<blockquote>
<p>注意</p>
<p>全局的常量或变量都是延迟计算的，跟延迟存储属性相似，不同的地方在于，全局常量或变量不需要标记lazy修饰符。</p>
<p>局部范围的常量或变量从不延迟计算</p>
</blockquote>
<h4 id="类型属性"><a href="#类型属性" class="headerlink" title="类型属性"></a>类型属性</h4><p>给类型定义属性，无论你创建多少个该类型的实例，这些属性都只有唯一一份。这种属性就是<code>类型属性</code></p>
<p>存储型类型属性可以是变量或常量，计算行类型属性跟实例的计算型属性一样只能定义成变量属性</p>
<h5 id="类型属性语法"><a href="#类型属性语法" class="headerlink" title="类型属性语法"></a>类型属性语法</h5><p>使用关键字 <code>static</code>定义类型属性。在为类定义计算型类型属性时，可以改用关键字 <code>class</code>来支持子类对父类的实现进行重写。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">struct SomeStructure &#123;</span><br><span class="line">	static var storedTypeProperty = &quot;Some Value&quot;</span><br><span class="line">	static var computedTypeProperty: Int &#123;</span><br><span class="line">		return 1</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum SomeEnumeration &#123;</span><br><span class="line">	static var storedTypeProterty = &quot;Some Value&quot;</span><br><span class="line">	static var computedTypeProperty: Int &#123;</span><br><span class="line">		return 6</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class SomeClass &#123;</span><br><span class="line">	static var storedTypeProperty = &quot;SomeValue&quot;</span><br><span class="line">	static var computedTypeProperty: Int &#123;</span><br><span class="line">		return 27</span><br><span class="line">	&#125;</span><br><span class="line">	cass var overridebaleProperty: Int &#123;</span><br><span class="line">		return 107</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">注意：</span><br><span class="line">跟实例的存储属性不同，必须给存储属性指定默认值。因为类型本身没有构造器，也就无法在初始化过程中使用构造器给类型属性赋值。</span><br><span class="line">存储型类型属性是延迟初始化的，他们只有再第一次访问的时候才会被初始化。即使他们被多个线程同时访问，系统也保证只会对其进行一次初始化，并且不需要对其使用`lazy`修饰符</span><br></pre></td></tr></table></figure>
<h5 id="获取和设置类型属性的值"><a href="#获取和设置类型属性的值" class="headerlink" title="获取和设置类型属性的值"></a>获取和设置类型属性的值</h5><p>跟实例属性一样，类型属性也是通过点语法访问。但是，类型属性是通过类型本身来访问，而不是通过实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let type = SomeClass.computedTypeProperty</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/23/Swift-ClassAndStruct/" data-id="cjvlqkh63000buib8mo0dob94" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Swift/">Swift</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-enum" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/19/enum/" class="article-date">
  <time datetime="2019-04-19T08:22:25.174Z" itemprop="datePublished">2019-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/19/enum/">枚举</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>枚举为一组关联的值定义了一个共同的类型，使你可以在你的代码中以<strong>类型安全</strong>的方式来使用这些值</p>
<h4 id="枚举语法"><a href="#枚举语法" class="headerlink" title="枚举语法"></a>枚举语法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum someEnumration&#123;</span><br><span class="line">	// 枚举定义放在这里</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">注：与 C 和 Objective-C 不同，Swift 的枚举成员在被创建时不会被赋予一个默认的整型值。</span><br></pre></td></tr></table></figure>
<h4 id="使用-Switch-语句匹配枚举值"><a href="#使用-Switch-语句匹配枚举值" class="headerlink" title="使用 Switch 语句匹配枚举值"></a>使用 Switch 语句匹配枚举值</h4><h4 id="关联值"><a href="#关联值" class="headerlink" title="关联值"></a>关联值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//表示两种商品条形码的枚举</span><br><span class="line">enum Barcode &#123;</span><br><span class="line">	case  upc(Int, Int, Int, Int)</span><br><span class="line">	case  qrCode(String)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var productBarcode = Barcode.upc(8, 32342, 1323, 3)</span><br><span class="line">productBarcode = .qrCode(&quot;ABCDEFGHIJKLMNOP&quot;)</span><br><span class="line">//这时，原始的 Barcode.upc 和其整数关联值被新的 Barcode.qrCode 和其字符串关联值所替代</span><br><span class="line"></span><br><span class="line">//用swift case 提取关联值</span><br><span class="line">switch productBarcode &#123;</span><br><span class="line">	case .cup(let numberSystem, let manufacturer, let product, let check):</span><br><span class="line">		print(&quot;UPC: \(numberSystem), \(manufacturer), \(product), \(check).&quot;)</span><br><span class="line">	case .qrCode(let productCode):</span><br><span class="line">		print(&quot;QR code: \(productCode).&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//为了简洁，也可以在成员名称前标注一个let或者var</span><br><span class="line">switch productBarcode &#123;</span><br><span class="line">case let .upc(numberSystem, manufacturer, product, check):</span><br><span class="line">    print(&quot;UPC: \(numberSystem), \(manufacturer), \(product), \(check).&quot;)</span><br><span class="line">case let .qrCode(productCode):</span><br><span class="line">    print(&quot;QR code: \(productCode).&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="原始值"><a href="#原始值" class="headerlink" title="原始值"></a>原始值</h4><p>使用 ASCII 码作为原始值的枚举：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum ASCIIControlCharacter: Character &#123;</span><br><span class="line">    case tab = &quot;\t&quot;</span><br><span class="line">    case lineFeed = &quot;\n&quot;</span><br><span class="line">    case carriageReturn = &quot;\r&quot;</span><br><span class="line">&#125;</span><br><span class="line"> 注意：原始值和关联值是不同的，原始值在定义枚举是被预先填充的值，像上述三个ASCII码。对于一个特定的枚举成员，它的原始值始终不变。关联值是创建一个基于枚举成员的常量或者变量时才设置的值，枚举成员的关联值可以变化</span><br></pre></td></tr></table></figure>
<h4 id="原始值的隐式赋值"><a href="#原始值的隐式赋值" class="headerlink" title="原始值的隐式赋值"></a>原始值的隐式赋值</h4><p>在使用原始值为<code>整数</code>或者<code>字符串</code>类型的枚举时，不需要显式地为每一个枚举成员设置原始值，Swift 将会自动为你赋值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enum Planet: Int &#123;</span><br><span class="line">    case mercury = 1, venus, earth, mars, jupiter, saturn, uranus, neptune</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用枚举成员的 rawValue 属性可以访问该枚举成员的原始值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let earthsOrder = Planet.earth.rawValue</span><br><span class="line">// earthsOrder 值为 3</span><br></pre></td></tr></table></figure>
<h4 id="使用原始值初始化枚举实例"><a href="#使用原始值初始化枚举实例" class="headerlink" title="使用原始值初始化枚举实例"></a>使用原始值初始化枚举实例</h4><p>如果在定义枚举类型的时候使用了原始值，那么将会自动获得一个初始化方法，这个方法接收一个叫做<code>rawValue</code>的参数，参数类型即为原始值类型，返回值则是枚举成员或nil</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let possiblePlanet = Planet(rawValue: 7)</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong><br>原始值构造器是一个可失败的构造器，因为并不是每一个原始值都有与之对应的枚举成员。</p>
<h4 id="递归枚举"><a href="#递归枚举" class="headerlink" title="递归枚举"></a>递归枚举</h4><p>递归枚举是一种枚举类型，它有一个或者多个枚举成员使用该枚举类型的实例作为关联值。你可以再枚举成员前面加上<code>indirect</code>来表示该成员可递归。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum ArithmeticExpression &#123;</span><br><span class="line">	case number(Int)</span><br><span class="line">	indirect case addition(ArithmeticExpression, ArithmeticExpression)</span><br><span class="line">	indirect case multiplication(ArithmeticExpression, ArithmeticExpression)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/19/enum/" data-id="cjvlqkh6b000luib8w9kx0br0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Swift/">Swift</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-closure" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/17/closure/" class="article-date">
  <time datetime="2019-04-17T10:38:17.728Z" itemprop="datePublished">2019-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/17/closure/">闭包</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="闭包定义"><a href="#闭包定义" class="headerlink" title="闭包定义"></a>闭包定义</h4><p>闭包是自包含的函数代码块，可以在代码中被传递和使用。</p>
<p>闭包可以捕获和存储所在上下文任意的常量和变量的引用</p>
<p>全局和嵌套函数实际上也是特殊的闭包，闭包采取如下三种形式之一</p>
<ul>
<li>全局函数是一个有名字但不会捕捉任何值的闭包</li>
<li>嵌套函数是一个有名字可以捕获其封闭函数域内值的闭包</li>
<li>闭包表达式是一个利用轻量级语法所写的可以捕获其上下文中变量或常量的匿名闭包</li>
</ul>
<h4 id="闭包表达式语法"><a href="#闭包表达式语法" class="headerlink" title="闭包表达式语法"></a>闭包表达式语法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//闭包表达式语法有如下的一般形式：</span><br><span class="line">&#123; (parameters) -&gt; return type in</span><br><span class="line">	statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>闭包表达是可以是in-out参数，但不能设定默认值</p>
<h4 id="单表达式闭包隐式返回"><a href="#单表达式闭包隐式返回" class="headerlink" title="单表达式闭包隐式返回"></a>单表达式闭包隐式返回</h4><p>单行表达式闭包可以省略 <code>return</code>关键字来隐士的返回单行表达式的结果。</p>
<p>sorted(by:{s1, s2 in s1 &gt; s2})<br>因为这里只包含了一个单一表达式 s1&gt;s2</p>
<h4 id="尾随闭包："><a href="#尾随闭包：" class="headerlink" title="尾随闭包："></a>尾随闭包：</h4><p>尾随闭包是一个写在函数括号之后的闭包表达式，函数将其作为最后一个参数调用。在使用尾随闭包时，你不用写出它的参数标签：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">someFunctionThatTakesAClosure()&#123;</span><br><span class="line">	//闭包主体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="闭包是引用类型"><a href="#闭包是引用类型" class="headerlink" title="闭包是引用类型"></a>闭包是引用类型</h4><h4 id="逃逸闭包："><a href="#逃逸闭包：" class="headerlink" title="逃逸闭包："></a>逃逸闭包：</h4><p>当一个闭包作为参数传到一个函数中，但是这个闭包在函数返回后才被执行，我们称该改闭包从函数中逃逸。@escaping 标记这个闭包是允许“逃逸”出这个函数的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var completeionHandles: [() -&gt; Void] = []</span><br><span class="line">func someFunctionWithEscapingClosure(completionHandler: @escaping () -&gt; Void)&#123;</span><br><span class="line">	completeionHandles.append(completionHandler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将一个闭包标记为 @escaping 意味着你必须在闭包中显式地引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func someFunctionWithNonescapingClosure(closure: () -&gt; Void)&#123;</span><br><span class="line">	closure()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SomeClass&#123;</span><br><span class="line">	var x = 10</span><br><span class="line">	func doSomething()&#123;</span><br><span class="line">		someFunctonWithEscapingClosure&#123; self.x = 100 &#125;</span><br><span class="line">		someFunctionWithNonescapingClosure&#123; x = 200 &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="自动闭包"><a href="#自动闭包" class="headerlink" title="自动闭包"></a>自动闭包</h4><p>自动闭包是一种自动创建的闭包，用于包装传递给函数作为参数的表达式。这种闭包不接受任何参数，当它被调用的时候会返回被包装在其中的表达式</p>
<p>自动闭包让你能够延迟求值，因为直到你调用这个闭包，代码段才会被执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var customersInLine = [&quot;Chris&quot;,&quot;Alex&quot;, &quot;Ewa&quot;, &quot;Barry&quot;,&quot;Daniella]</span><br><span class="line">print(customersInLine.count)</span><br><span class="line">// 打印出 &quot;5&quot;</span><br><span class="line">let customerProvider = &#123; customersInLine.remove(at: 0) &#125;</span><br><span class="line">print(customersInLine.count)</span><br><span class="line">// 打印出 &quot;5&quot;</span><br><span class="line">print(&quot;Now serving&quot;)</span><br></pre></td></tr></table></figure>
<p>如果你想让一个自动闭包可以“逃逸”，则应该同时使用 <code>@autoclosure</code>和 <code>@escaping</code>属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var customersInLine = [&quot;Barry&quot;,&quot;Daniella&quot;]</span><br><span class="line">var customerProviders: [() -&gt; String] = []</span><br><span class="line">func collectCustomerProviders(_ customerProvider: @autoclosure @escaping () -&gt; String)&#123;</span><br><span class="line">	customerProviders.append(customerProvider)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">collectCustomerProviders(customersInLine.remove(at: 0))</span><br><span class="line">collectCustomerProviders(customersInLine.remove(at: 0))</span><br><span class="line">print(&quot;Collected \(customerProviders.count) closures.&quot;)</span><br><span class="line">// 打印 &quot;Collected 2 closures.&quot;</span><br><span class="line">for customerProvider in customerProviders &#123;</span><br><span class="line">    print(&quot;Now serving \(customerProvider())!&quot;)</span><br><span class="line">&#125;</span><br><span class="line">// 打印 &quot;Now serving Barry!&quot;</span><br><span class="line">// 打印 &quot;Now serving Daniella!&quot;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/17/closure/" data-id="cjvlqkh6f000uuib8olrv0ci9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Swift/">Swift</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-block" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/16/block/" class="article-date">
  <time datetime="2019-04-16T10:59:32.542Z" itemprop="datePublished">2019-04-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/16/block/">浅谈iOS中的Block</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="block-的修饰符为什么选copy"><a href="#block-的修饰符为什么选copy" class="headerlink" title="block 的修饰符为什么选copy"></a><strong>block 的修饰符为什么选copy</strong></h3><p>想必很多开发人员知道一般用copy修饰block,接下来讲解为什么需要用copy,甚至会讲到其实用strong修身符也是可以的.<br>在Objective-C 语言中,一共有3中类型的block:</p>
<ol>
<li>_NSConcreteGlobalBlock 全局静态block,不会访问外部局部变量</li>
<li>_NSConcreteStackBlock 保存在栈区中的block,但函数返回时会被销毁.</li>
<li>_NSConcreteMallocBlock 保存在堆中的block,当引用计数为0时会被销毁.</li>
</ol>
<p><strong>总结:</strong></p>
<ul>
<li>block内部没有调用外部局部变量时存放在全局区(ARC和MRC下均是)</li>
<li>block使用了外部局部变量,这种情况下也是我们平时常用的方式.MRC:Block的内部地址显示在栈区,栈区的特点就是创建的对象随时可能被销毁,一旦被销毁后续在次调用空对象就可能会造成程序崩溃,在对block进行copy后,block存放在堆区.所以在使用block属性时使用copy修饰.但ARC中block都会在堆上的,系统默认会对block进行copy操作.</li>
<li>使用copy,strong修身block在ARC和MRC都可以的,都是在堆区</li>
</ul>
<p><strong>补充:</strong></p>
<p>一个block要使用self.会在block外部申明一个weak变量指向self,然而为何有时会block里又申明一个strong变量指向weakSelf?</p>
<p><strong>原因:</strong></p>
<p>block会把写在block里面的变量copy一份,如果直接在block里面使用self,(self对变量默认是强引用)self对block持有,block对self持有,导致循环引用.所以这里需要声明一个弱引用weakSelf,让block引用weakSelf,打破循环引用.<br>而这样会导致另外一个问题,因为weakSelf对self是弱引用,如果这个时候控制器pop或者其他方式使引用计数为0,就会释放,如果block是异步调用,而且调用的时候self已经释放了,这个时候weakSelf已经变成nil了.当控制器(也可以是其他控制器)pop回来之后(或者一些其他原因导致释放),网络请求完成,如果这个时候需要控制器作出反应,需要strongSelf再对weakSelf强引用一下.但是,你可能会疑问,strongSelf对weakSelf强引用,weakSelf对self弱引用,最终也是对self进行了强引用,会导致循环引用吗?不会的,因为strongSelf是在block里声明的指针,当block执行结束后,strongSelf会释放,这个时候不将不再强引用weakSelf,所以self会正确的释放.</p>
<h3 id="Bolck-和-Deleagte-的区别"><a href="#Bolck-和-Deleagte-的区别" class="headerlink" title="Bolck 和 Deleagte 的区别"></a>Bolck 和 Deleagte 的区别</h3><p>block 和delegate 本质上都是回调,</p>
<p><strong>在编码风格上</strong></p>
<ul>
<li>block更轻型,使用简单,能够直接访问上下问.使用block代码使代码更加紧凑,降低了代码的分散程度.使用deleagte,首先要去申明protocol协议,并且写上回调方法.然后在要实现的协议类中去实现.编码风格计较零散.</li>
</ul>
<p><strong>源头上的区别:</strong></p>
<ul>
<li>delegate运行成本低,block的运行成本高.block出栈需要将使用的数据从栈内存拷贝到堆内存,当然对象的话就是引用计数+1,使用完成或者block置nil后才能销毁.deleagte只保存了一个对象指针(要用weak修饰deleagte,不然也会造成循环引用),直接回调,没有其他额外的消耗.</li>
</ul>
<p><strong>使用场景上的区别</strong></p>
<ul>
<li>多个相关方法.假如每个方法都设置一个block,这样会更麻烦.而deleagte让多个方法分成一组,只需要设置一次,就可以多次回调了.当多于3个方法时就应该优先采用delegate.当1,2个回调时则使用block</li>
<li>deleagte更安全些,比如:避免循环引用.使用block时稍微不注意就形成循环引用,导致对象释放不了.这种循环引用,一旦出现就比较难检查出来.而deleagte的方法时分开的.并不会引用上下文,因此更安全些.</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/16/block/" data-id="cjvlqkh66000euib86g0c0lrt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/oc中为什么会用copy修饰block、block和deleagte的区别/">oc中为什么会用copy修饰block、block和deleagte的区别</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/NSDictionary的内部实现原理/">NSDictionary的内部实现原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Swift/">Swift</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/github上的项目拖管到cocoapod/">github上的项目拖管到cocoapod</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS/">iOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS中的锁信号量和互斥锁的区别-synchronized/">iOS中的锁	信号量和互斥锁的区别  @synchronized</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/oc中为什么会用copy修饰block、block和deleagte的区别/">oc中为什么会用copy修饰block、block和deleagte的区别</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构相关定义/">数据结构相关定义</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/NSDictionary的内部实现原理/" style="font-size: 10px;">NSDictionary的内部实现原理</a> <a href="/tags/Swift/" style="font-size: 20px;">Swift</a> <a href="/tags/github上的项目拖管到cocoapod/" style="font-size: 10px;">github上的项目拖管到cocoapod</a> <a href="/tags/iOS/" style="font-size: 10px;">iOS</a> <a href="/tags/iOS中的锁信号量和互斥锁的区别-synchronized/" style="font-size: 10px;">iOS中的锁	信号量和互斥锁的区别  @synchronized</a> <a href="/tags/oc中为什么会用copy修饰block、block和deleagte的区别/" style="font-size: 10px;">oc中为什么会用copy修饰block、block和deleagte的区别</a> <a href="/tags/数据结构相关定义/" style="font-size: 10px;">数据结构相关定义</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/05/05/fanxing/">泛型</a>
          </li>
        
          <li>
            <a href="/2019/04/30/Protocol/">协议</a>
          </li>
        
          <li>
            <a href="/2019/04/28/extension/">扩展</a>
          </li>
        
          <li>
            <a href="/2019/04/25/option/">可选链 、错误处理、类型转换、嵌套类型</a>
          </li>
        
          <li>
            <a href="/2019/04/24/init/">构造过程与析构过程</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 ZQing<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>